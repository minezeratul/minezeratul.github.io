[{"content":"如何理解quickSort? 最近在复习快排，便重新整理了一下，除了classic quickSort 还有变种quickSelectionSort(随机快排)，如215、1738，还有Dual-Pivot Partition、Three-Way Partition。 不同的partition复用，使其在面对不同情况下有不同的效果\n最常见的快排，最坏的情况是 1.已经/几乎有序 → 退化成冒泡排序\n2.pivot刚好是最大值/最小值\nHoare quickSort, 这个版本的算法在含有许多重复元素的情况下，可以避免其出现最坏情况的划分\npublic int partition(int[] a , int lo , int hi){ int p = a[lo]; int i = lo - 1 , j = hi + 1; while(true){ while(a[--j] \u0026gt; p); while(a[++i] \u0026lt; p); if(i \u0026lt; j) swap(a , i , j); else return j ; } } 这是改进后的，也是我们现在最常用的版本\npublic void quickSort(int[] arr){ quickSort(arr , 0 , arr.length - 1); } public void quickSort(int[]arr , int first , int last){ if (last \u0026gt; first){ int pivotIndex = partition(arr , first , last); quickSort(arr , first , pivotIndex - 1); quickSort(arr , pivotIndex + 1, last); } } public int partition(int[]arr , int first , int last){ int pivot = arr[first]; int low = first + 1; int high = last; while (high \u0026gt; low){ //Search left to right  while (high \u0026gt;= low \u0026amp;\u0026amp; arr[low] \u0026lt;= pivot){ low++; } //Search right to left  while (high \u0026gt;= low \u0026amp;\u0026amp; arr[high] \u0026gt; pivot){ high--; } if (high \u0026gt; low){ //swap the element in the array  swap(arr , low , high); } } while (high \u0026gt; first \u0026amp;\u0026amp; arr[high] \u0026gt;= pivot){ high--; } //swap the pivot  if (pivot \u0026gt; arr[high]){ swap(arr , first , high) return high; } else { return first; } } private void swap(int[] arr , int i , int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 随机化 先洗牌后partition , 随机生成pivot , 然而并没有改变最坏情况下的运行时间，只是减少了出现最坏情况的可能，即无法保证每次pivot都是正中间的索引的。\n且quickSelectionSort不关心a[ lo\u0026hellip;p - 1] 和 a[p + 1 \u0026hellip; hi] 是否 有序 ，此方法一般应用于找Kth Element\nprivate int partition(int[] nums, int lo, int hi) { if (lo == hi) { return lo; } int pivot = nums[lo]; // j = hi + 1 因为 while 中会先执行--  int i = lo, j = hi + 1; while (true) { // 保证 nums[lo..i] 都小于 pivot  while (nums[++i] \u0026lt; pivot) { if (i == hi) { break; } } // 保证 nums[j..hi] 都大于 pivot  while (nums[--j] \u0026gt; pivot) { if (j == lo) { break; } } if (i \u0026gt;= j) { break; } swap(nums, i, j); } //交换pivot  swap(nums, j, lo); // 如果走到这里，一定有：  // nums[i] \u0026gt; pivot \u0026amp;\u0026amp; nums[j] \u0026lt; pivot  // 所以需要交换 nums[i] 和 nums[j]，  // 保证 nums[low..i] \u0026lt; pivot \u0026lt; nums[j..high]  return j; } private void shuffle(int[] nums) {//打乱数组  int n = nums.length; Random ran = new Random(); for (int i = 0; i \u0026lt; n; i++) { int r = i + ran.nextInt(n - i); swap(nums, i, r); } } //another ver. public int randomPartition(int[] a, int l, int r) { int i = random.nextInt(r - l + 1) + l; swap(a, i, r); return partition(a, l, r); } Lomuto划分 一个数组被分成三段 ，设最左为pivot , 一段是\u0026lt;a[pivot] , 一段\u0026gt;a[pivot] , 还有一段未处理的数据\n从左往右扫描数组，将第三段未处理的数据和p比较 , 其中 s指向 第一段末尾 ， i指向 第二段末尾\n若val \u0026gt;= a[p] 则 i++ / 若val \u0026lt;= a[p] , 则需要s++ ， 并和a[i]互换 ,然后 i++ ，继续指向尾端\n直到第三段为空，a[s] 与 a[pivot] 交换\n\rLomuto\r\npublic void quickSort(int[] a , int l , int r){ if(l \u0026lt; r){ int p = partition(a , l , r); quickSort(a , l , p - 1); quickSort(a , p + 1 , r); } } private int partition(int[] a ,int l, int r) { int p = a[l]; int s = l; for (int i = l + 1; i \u0026lt;= r; i++) { if (a[i] \u0026lt; p) { s = s + 1; int temp = a[s]; a[s] = a[i]; a[i] = temp; } } int temp = a[l]; a[l] = a[s]; a[s] = temp; return s; } Dual-Pivot Partition Arrays.sort()就是用该方法实现的\n 对于长度小于17的数组使用插入排序(常见优化步骤，传统快排也有应用)。 选择两个枢纽元p1,p2，一般选择起始元素a[left]和末尾元素a[right]（有其他选取方式）。 假设p1\u0026lt;p2，如果不是就交换。 将整个数组分成三部分，分别为 \u0026lt;p1的 , p1\u0026lt;X\u0026lt;p2 , \u0026gt;p2 的。 递归排序这三个部分。  \rDual-Pivot\r\n这样进行一次后递归的进行下一次双轴快排，一直到结束，但是在这个执行过程应该去如何处理分析呢？需要几个参数呢？\n 假设知道排序区间[start，end]。数组为arr， pivot1=arr[start],pivot2=arr[end] 还需要三个参数left，right和k。 l left初始为start，[start,left]区域即为小于等于pivot1小的区域(第一个等于)。 right与left对应，初始为end，[right,end]为大于等于pivot2的区域(最后一个等于)。 k初始为start+1，是一个从左往右遍历的指针，遍历的数值与pivot1，pivot2比较进行适当交换，当k\u0026gt;=right即可停止。  \rpre1\r\nk交换过程然后你可能会问k遍历时候究竟怎么去交换？left和right该如何处理呢？不急我带你慢慢分析，首先K是在left和right中间的，遍历k的位置和pivot1，pivot2进行比较：如果arr[k]\u0026lt;pivot1,那么先++left，然后swap(arr,k,left),**因为初始在start在这个过程不结束start先不动。**然后k++；继续进行\n\rpre2\r\n而如果arr[k]\u0026gt;pivot2.(区间自行安排即可) 有点区别的就是right可能连续的大于arr[k],比如9 3 3 9 7如果我们需要跳过7前面9到3才能正常交换，这和快排的交换思想一致，当然再具体的实现上就是right\u0026ndash;到一个合适比arr[k]小的位置。然后swap(arr,k,right)**切记此时k不能自加。**因为带交换的那个有可能比pivot1还小要和left交换。如果是介于两者之间，k++即可\n\rpre3\r\n最后则是在执行完这一趟即k=right之后，即开始需要将pivot1和pivot2的数值进行交换\nswap(arr, start, left); swap(arr, end, right); 然后三个区间根据编号递归执行排序函数即可。\n\rpre4\r\npublic void dualPivotQuickSort(int[] arr, int start, int end) { if(start \u0026gt; end){ return; } if(arr[start] \u0026gt; arr[end]) swap(arr, start, end); int pivot1 = arr[start] , pivot2 =a rr[end]; //取最左侧和最右侧作为pivot  //(start，left]:左侧小于等于pivot1 [right,end)大于pivot2  int left = start , right = end, k = left + 1; while (k \u0026lt; right) { //和左侧交换  if(arr[k] \u0026lt;= pivot1) { //需要交换  swap(arr, ++left, k++); } else if (arr[k]\u0026lt;=pivot2) {//在中间的情况  k++; } else { while (arr[right]\u0026gt;=pivot2) {//如果全部小于直接跳出外层循环  if(right--==k) break ; } if(k\u0026gt;=right)break ; swap(arr, k, right); } } swap(arr, start, left); swap(arr, end, right); //分段递归，继续排序  dualPivotQuickSort(arr, start, left-1); dualPivotQuickSort(arr, left+1, right-1); dualPivotQuickSort(arr, right+1, end); } private void swap(int arr[],int i,int j){ int team=arr[i]; arr[i]=arr[j]; arr[j]=team; } Three-Way Partition ， 三路快排 , Dijkstra / Bentley-McIlroy 以最左元素、最右元素、最中间元素为pivot ，在双轴快排的基础上，在分一个等于p的区段\nprivate void sort(Comparable[] arr, int l, int r){ // 对于小规模数组, 使用插入排序  if(r - l \u0026lt;= 15){ InsertionSort.sort(arr, l, r); return; } // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot  swap(arr, l, (int)(Math.random()*(r-l+1)) + l ); Comparable v = arr[l]; int lt = l; // arr[l+1...lt] \u0026lt; v  int gt = r + 1; // arr[gt...r] \u0026gt; v  int i = l + 1; // arr[lt+1...i) == v  while(i \u0026lt; gt){ if(arr[i].compareTo(v) \u0026lt; 0){ swap( arr, i, lt + 1); i++; lt++; } else if(arr[i].compareTo(v) \u0026gt; 0){ swap(arr, i, gt - 1); gt--; } else{ // arr[i] == v  i++; } } swap(arr, l, lt); sort(arr, l, lt-1); sort(arr, gt, r); } private void swap(Object[] arr, int i, int j) { Object t = arr[i]; arr[i] = arr[j]; arr[j] = t; } Dijkstra / Bentley-McIlroy的源码 , 在无重复值的情况下，Bentley-McIlroy方法相较于双轴快排， 由于头尾只有少量的等值元素需要交换，所以额外的开销很小。\n// Dijkstra 3-way partitioning private static void sort(Comparable[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; int lt = lo, gt = hi; Comparable v = a[lo]; int i = lo+1; while (i \u0026lt;= gt) { int cmp = a[i].compareTo(v); if (cmp \u0026lt; 0) exch(a, lt++, i++); else if (cmp \u0026gt; 0) exch(a, i, gt--); else i++; } sort(a, lo, lt - 1); sort(a, gt + 1, hi); } // Bentley-McIlroy 3-way partitioning private static void sort(Comparable[] a, int lo, int hi) { int i = lo, j = hi+1; int p = lo, q = hi+1; Comparable v = a[lo]; while (true) { while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; // pointers cross  if (i == j \u0026amp;\u0026amp; eq(a[i], v)) exch(a, ++p, i); if (i \u0026gt;= j) break; exch(a, i, j); if (eq(a[i], v)) exch(a, ++p, i); if (eq(a[j], v)) exch(a, --q, j); } i = j + 1; //多了交换的步骤  for (int k = lo; k \u0026lt;= p; k++) exch(a, k, j--); for (int k = hi; k \u0026gt;= q; k--) exch(a, k, i++); } ","date":"2021-05-22T21:08:13+08:00","image":"https://minezeratul.github.io/p/quicksort/wallhaven-y858yd_hu5438825b9b6d1014226d20d231e650c2_2128318_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/quicksort/","title":"Collections of quickSort"},{"content":"Leetcode 1738 这是Leetcode 5.19的题目 1738. 找出第 K 大的异或坐标值 ，是215. 数组中的第K个最大元素 的二维异或版本 215回顾\n第一种方法，用前缀异或 + PriorityQueue , Java是用最小堆实现pq\npublic int kthLargestValue(int[][] matrix, int k) { int m = mat.length , n = mat[0].length; int[][] pre = new int[m + 1][n + 1]; PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= m ; i++) { for (int j = 1; j \u0026lt;= n ; j++) { //二维数组的前缀异或  pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ mat[i - 1][j - 1]; if (pq.size() \u0026lt; k){ pq.add(pre[i][j]); }else { if (pre[i][j] \u0026gt; pq.peek()){ //大于size直接去掉  //直到剩下K个值  //pq.peek()即是题目想要的第K大  pq.poll(); pq.add(pre[i][j]); } } } } return pq.peek(); } } 第二种方法，用前缀异或 + 排序\npublic int kthLargestValue(int[][] matrix, int k) { int m = matrix.length , n = matrix[0].length; int[][] prefix = new int[m + 1][n + 1]; List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); /** 二维数组的前缀异或 */ for (int i = 1; i \u0026lt;= m ; i++) { for (int j = 1; j \u0026lt;= n ; j++) { prefix[i][j] = prefix[i - 1][j] ^ prefix[i][j - 1] ^ prefix[i - 1][j - 1] ^ matrix[i - 1][j - 1]; list.add(prefix[i][j]); } } //这里用了Collections.sort(List , new Comparator(){  // @Override  //\tpublic int compare(Object o1 , Object o2) \t//});  //当o2 - o1 \u0026gt; 0 ,即把大的值放前面  //降序排列  Collections.sort(list, ((o1, o2) -\u0026gt; o2 - o1)); return list.get(k - 1); } ","date":"2021-05-22T19:47:51+08:00","image":"https://minezeratul.github.io/p/13rd-blog/wallhaven-3z3zdv_hu5438825b9b6d1014226d20d231e650c2_1578832_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/13rd-blog/","title":"K-Largest XOR Value"},{"content":"Leetcode K-Largest Val 215. 数组中的第K个最大元素 , 题目需要 在未排序的数组找到第 k 个最大的元素 ，而且不是第k个不同的元素\n先看简单方法，用Java的PriorityQueue来解答，需注意的是PriorityQueue是用小顶堆实现的\npublic int findKthLargest2(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); //小顶堆去除元素  for (int num : nums) { pq.offer(num); if (pq.size() \u0026gt; k) { //因为我们只需要找到第K大的数,超过size直接去除堆顶元素就好  pq.poll(); } } return pq.peek(); } 亦或者和官方解答一样，用大顶堆实现也可以得出第K大的数\npublic int findKthLargest(int[] nums, int k) { int heapSize = nums.length; buildMaxHeap(nums, heapSize); for (int i = nums.length - 1; i \u0026gt;= nums.length - k + 1; --i) { swap(nums, 0, i); --heapSize; maxHeapify(nums, 0, heapSize); } return nums[0]; } public void buildMaxHeap(int[] a, int heapSize) { for (int i = heapSize / 2; i \u0026gt;= 0; i--) { maxHeapify(a, i, heapSize); } } public void maxHeapify(int[] a, int i, int heapSize) { int l = i * 2 + 1, r = i * 2 + 2, largest = i; if (l \u0026lt; heapSize \u0026amp;\u0026amp; a[l] \u0026gt; a[largest]) { largest = l; } if (r \u0026lt; heapSize \u0026amp;\u0026amp; a[r] \u0026gt; a[largest]) { largest = r; } if (largest != i) { swap(a, i, largest); maxHeapify(a, largest, heapSize); } } private void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } 第三种方法则是用quickSelectionSort 快速选择排序\npublic int findKthLargest(int[] nums, int k) { int low = 0, high = nums.length - 1; //因为无法保证每次pivot都是正中间的索引的  //所以我们需要对数组进行一次随机洗牌  shuffle(nums); k = nums.length - k; while (low \u0026lt;= high) { int p = partition(nums, low, high); if (p \u0026lt; k) { low = p + 1; } else if (p \u0026gt; k) { high = p - 1; } else { return nums[p]; } } return -1; } private int partition(int[] nums, int lo, int hi) { if (lo == hi) { return lo; } int pivot = nums[lo]; // j = hi + 1 因为 while 中会先执行--  int i = lo, j = hi + 1; while (true) { // 保证 nums[lo..i] 都小于 pivot  while (nums[++i] \u0026lt; pivot) { if (i == hi) { break; } } // 保证 nums[j..hi] 都大于 pivot  while (nums[--j] \u0026gt; pivot) { if (j == lo) { break; } } if (i \u0026gt;= j) { break; } //到了这一步的时候  //一定会有nums[i] \u0026gt; pivot \u0026amp;\u0026amp; nums[j] \u0026lt; pivot  //因此我们要交换num[i]和num[j]  //保证nums[low..i] \u0026lt; pivot \u0026lt; nums[j..high]  swap(nums, i, j); } //交换pivot  swap(nums, j, lo); // 现在 nums[low..j-1] \u0026lt; nums[j] \u0026lt; nums[j+1..high]  return j; } private void shuffle(int[] nums) {//随机打乱  int n = nums.length; Random ran = new Random(); for (int i = 0; i \u0026lt; n; i++) { int r = i + ran.nextInt(n - i); swap(nums, i, r); } } private void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } ","date":"2021-05-22T19:27:24+08:00","image":"https://minezeratul.github.io/p/12nd-blog/wallhaven-v9z9wl_hu5438825b9b6d1014226d20d231e650c2_1928554_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/12nd-blog/","title":"Largest Val in my mind xD"},{"content":"Database / SQL Code Student(Sid,Sname,Sage,Ssex) 学生表\nSid：学号；Sname：学生姓名；Sage：学生年龄；Ssex：学生性别\nCourse(Cid,Cname,Tid) 课程表\nCid,课程编号；Cname：课程名字；Tid：教师编号\nSC(Sid,Cid,score) 成绩表\nSid：学号；Cid,课程编号；score：成绩\nTeacher(Tid,Tname) 教师表\nTid：教师编号； Tname：教师名字\nCREATE TABLE Student ( Sid INT PRIMARY KEY NOT NULL, Sname nvarchar(32) NOT NULL, Sage DATETIME NOT NULL, Ssex nvarchar(8) NOT NULL ) CREATE TABLE Course ( Cid INT PRIMARY KEY, Cname nvarchar(32) NOT NULL, Tid INT NOT NULL ) CREATE TABLE SC ( Sid INT NOT NULL, Cid INT NOT NULL, score INT NOT NULL, PRIMARY KEY(Sid , Cid) ) CREATE TABLE Teacher ( Tid INT PRIMARY KEY NOT NULL, Tname nvarchar(16) NOT NULL ) 问题： 1、查询“001”课程比“002”课程成绩高的所有学生的学号； SELECT Sid FROM SC AS a , SC AS b where a.Sid = b.Sid And a.Cid = \u0026#34;001\u0026#34; And b.Cid = \u0026#34;002\u0026#34; And a.score \u0026gt; b.score; 2、查询平均成绩大于60分的同学的学号和平均成绩； SELECT Sid , AVG(Score) FROM SC GROUP BY Sid HAVING AVG(Score) \u0026gt; 60; 3、查询所有同学的学号、姓名、选课数、总成绩； SELECT Sid , Sname , COUNT(SC.Cid) as ClassNum , SUM(SC.Score) As Score FROM Student LEFT JOIN SC; 4、查询姓“李”的老师的个数； SELECT COUNT(DISTINCT(Tname)) From Teacher WHERE Tname LIKE \u0026#39;李%\u0026#39;; 5、查询没学过“叶平”老师课的同学的学号、姓名； SELECT Sid , Sname FROM Student WHERE Sid NOT IN( SELECT DISTINCT Sid FROM SC WHERE Cid IN ( SELECT Cid FROM course WHERE Tid = ( SELECT Tid FROM Teacher WHERE Tname = \u0026#34;叶平\u0026#34; ) ) ); 6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名； SELECT Sid , Sname FROM Student , SC WHERE Sid = SC.Sid AND EXISTS( Select * from SC as SC_2 where SC_2.SID = SC.SID and SC_2.Cid =\u0026#39;002\u0026#39; ); 7、查询学过“叶平”老师所教的所有课的同学的学号、姓名； SELECT Sid , Sname FROM Student WHERE Sid IN( SELECT DISTINCT Sid FROM SC WHERE cid IN ( SELECT Cid FROM course WHERE Tid = ( SELECT Tid FROM Teacher WHERE Tname = \u0026#34;叶平\u0026#34; ) ) ); 8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名； SELECT DISTINCT Sid , Sname FROM Student , SC AS a , SC AS b WHERE a.Sid = b.Sid AND a.Cid = \u0026#39;001\u0026#39; AND b.Cid = \u0026#39;002\u0026#39; AND a.Score \u0026gt; b.Score 9、查询所有课程成绩小于60分的同学的学号、姓名； SELECT Sid , Sname FROM Student , SC WHERE Sid = SC.Sid AND Sc.Score \u0026lt; 60; 13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩； UPDATE SC SET Score = (SELECT AVG(a.Score) FROM SC AS a , SC AS QEb WHERE a.Cid = b.Cid) FROM Course , Teacher WHERE Teacher.Tid = Course.Tid AND Course.Cid = SC.Cid AND Teacher.Tname = \u0026#39;叶平\u0026#39;; 14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名； SELECT Sid , Sname FROM Student , SC WHERE Student.Sid = SC.Sid AND Cid IN (SELECT Cid FROM SC WHERE Sid =\u0026#39;1002\u0026#39;) GROUP BY Sid HAVING COUNT(*) = (SELECT COUNT(*) FROM SC WHERE Sid =\u0026#39;1002\u0026#39;); 15、删除学习“叶平”老师课的SC表记录； DELETE SC FROM Course , Teacher , SC WHERE Course.Cid = SC.Cid AND Teacher.Tid = Course.Tid AND Teacher.Tname = \u0026#39;叶平\u0026#39;; 17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示： 学生ID,,数据库,企业管理,英语,有效课程数,有效平均分 SELECT Sid as StuID , (SELECT score FROM SC WHERE SC.Sid = t.id AND Cname = \u0026#39;Database\u0026#39;) AS DataBaseSYS , (SELECT score FROM SC WHERE SC.Sid = t.Sid AND Cname =\u0026#39;Management\u0026#39;) AS Management , (SELECT score FROM SC WHERE SC.Sid = t.Sid AND Cname =\u0026#39;English \u0026#39;) AS English , COUNT(*) AS 有效课程数, AVG(t.score) AS 平均成绩 FROM SC AS t GROUP BY Sid ORDER BY AVG(t.score) 18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分 SELECT Cid AS CourseID , a.Score AS MaxScore , b.Score AS MinScore FROM Course , SC AS a , SC AS b WHERE a.Cid = b.Cid AND MaxScore = ( SELECT MAX(c.Score) FROM SC AS c , Student WHERE c.Sid = Student.Sid AND a.Cid = c.Cid GROUP BY c.Cid ) AND MinScore = ( SELECT MIN(d.Score) FROM SC AS d WHERE b.Cid = d.Cid GROUP BY d.Cid ); 19、按各科平均成绩从低到高和及格率的百分数从高到低顺序 SELECT Cid , AVG(SCORE) AS AVERAGE , SUM(CASE WHEN SC.score \u0026gt;= 60 THEN 1 ELSE 0 END)/COUNT(*) AS PassRate FROM SC , Course WHERE SC.Cid = Course.Cid, GROUP BY Cid , ORDER BY AVERAGE ASC, PassRate DESC; 21、查询不同老师所教不同课程平均分从高到低显示 SELECT Tid , Cid , AVG(Score) AS AVERAGE FROM SC , Teacher , Course WHERE Teacher.Tid = Course.Tid AND Course.Cid = SC.Cid GROUP BY Course.Cid ORDER BY AVERAGE DESC; 23、统计列印各科成绩,各分数段人数:课程ID,课程名称,[100-85],[85-70],[70-60],[ \u0026lt;60] SELECT Cid , Cname , SUM(CASE WHEN SC.score \u0026lt; 60 THEN 1 ELSE 0 END)/COUNT(*) AS LowerThan60 SUM(CASE WHEN SC.score \u0026gt;= 60 AND SC.Score \u0026lt; 70 THEN 1 ELSE 0 END)/COUNT(*) AS Between60And70 SUM(CASE WHEN SC.score \u0026gt;= 70 AND SC.Score \u0026lt; 85 THEN 1 ELSE 0 END)/COUNT(*) AS Between70And85 SUM(CASE WHEN SC.score \u0026gt;= 85 AND SC.Score \u0026lt;= 100 THEN 1 ELSE 0 END)/COUNT(*) AS Between85And100 FROM Course , SC WHERE SC.Cid = Course.Cid GROUP BY SC.Cid , Cname; 24、查询学生平均成绩及其名次 SELECT 1 + (SELECT COUNT(DISTINCT AVERAGE) FROM ( SELECT Sid , AVG(SCORE) AS AVERAGE FROM SC GROUP BY Sid ) AS T1 WHERE AVERAGE \u0026gt; T2.AVERAGE) AS Rank , Sid AS StuID , FROM (SELECT Sid, AVG(SCORE) AS AVERAGE FROM SC GROUP BY Sid ) AS T2 ORDER BY AVERAGE DESC; 25、查询各科成绩前三名的记录:(不考虑成绩并列情况) SELECT Sid , Cid , Score FROM SC AS A WHERE SCORE IN (SELECT TOP 3 Score From SC WHERE a.Cid = SC.Cid ORDER BY Score DESC ) ORDER BY Cid; 26、查询每门课程被选修的学生数 SELECT Cid ,COUNT(Sid) FROM SC GROUP BY Cid; 27、查询出只选修了一门课程的全部学生的学号和姓名 SELECT Sid , Sname , COUNT(Cid) FROM Student , SC WHERE Student.Sid = SC.Sid GROUP BY Sid , Sname HAVING COUNT(Cid) = 1; 28、查询男生、女生人数 SELECT COUNT(a.Ssex) AS Male FROM Student GROUP BY Ssex HAVING Ssex = \u0026#39;男\u0026#39;; SELECT COUNT(b.Ssex) AS Female FROM Student GROUP BY Ssex HAVING Ssex = \u0026#39;女\u0026#39;; 29、查询姓“张”的学生名单 SELECT Sname FROM Student WHERE Sname like \u0026#39;张%\u0026#39;; 30、查询同名同性学生名单，并统计同名人数 SELECT Sname , Ssex , COUNT(*) FROM Student GROUP BY Sname HAVING COUNT(*) \u0026gt; 1 31、1981年出生的学生名单(注：Student表中Sage列的类型是datetime) SELECT Sname , Sid , CONVERT(char (11),DATEPART(year,Sage) AS AGE FROM Student WHERE AGE = \u0026#39;1981\u0026#39;; 32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列 SELECT Cid ,AVG(Score) FROM SC GROUP BY Cid ORDER BY AVG(Score), Cid DESC ; 33、查询平均成绩大于85的所有学生的学号、姓名和平均成绩 SELECT Sid , Sname , AVG(Score) AS AVERAGE FROM Student , SC WHERE Student.Sid = SC.Sid GROUP BY SC.Sid , Sname HAVING AVG(Score) \u0026gt; 85; 34、查询课程名称为“数据库”，且分数低于60的学生姓名和分数 SELECT Sname , Score FROM Student , SC , Course WHERE Student.Sid = SC.Sid AND Course.Cid = SC.Cid AND Course.Cname = \u0026#39;数据库\u0026#39; AND Score \u0026lt; 60; 35、查询所有学生的选课情况； SELECT Sid , Sname , Cid , Cname FROM Student , Course , SC WHERE Student.Sid = SC.Sid AND Course.Cid = SC.Cid; 36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数； SELECT DISTINCT Student.Sid , Student.Sname , SC.Cid , SC.Score FROM Student , SC WHERE SC.score \u0026gt;= 70 AND SC.Sid = Student.Sid; 37、查询不及格的课程，并按课程号从大到小排列 SELECT Cid FROM SC WHERE Score \u0026lt; 60 ORDER BY Cid; 38、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名； SELECT Sid , Sname FROM Student , SC WHERE Student.Sid = SC.Sid AND SC.Cid = \u0026#39;003\u0026#39; AND SC.Score \u0026gt; 80; 40、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩 SELECT Sname , Score FROM Student , SC , Course WHERE Student.Sid = SC.Sid AND Course.Cid = SC.Cid AND Course.Tname = \u0026#39;叶平\u0026#39; AND Score = (SELECT Max(Score) FROM SC WHERE Cid = SC.Cid ) 41、查询各个课程及相应的选修人数 SELECT COUNT(*) FROM SC GROUP BY Cid; 43、查询每门功成绩最好的前两名 SELECT Sid , Cid , Score FROM SC AS a WHERE Score IN ( SELECT TOP 2 Score FROM SC WHERE a.Cid = SC.Cid ORDER BY Score DESC ); 44、统计每门课程的学生选修人数（超过10人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，查询结果按人数降序排列，若人数相同，按课程号升序排列 SELECT Cid , COUNT(DISTINCT Sid) FROM SC GROUP BY Cid HAVING COUNT(DISTINCT Sid) \u0026gt; 10 ORDER BY COUNT(DISTINCT Sid) DESC , Cid ASC; 45、检索至少选修两门课程的学生学号 SELECT Sid FROM SC GROUP BY Sid HAVING COUNT(*) \u0026gt;= 2; 46、查询全部学生都选修的课程的课程号和课程名 SELECT Cid , Cname FROM Course ; 47、查询没学过“叶平”老师讲授的任一门课程的学生姓名 SELECT Sname FROM Student WHERE Sid NOT IN (SELECT Sid FROM SC , Course , Teacher WHERE Course.Cid = SC.Cid AND Teacher.Tid = Course.Tid AND Teacher.Tname = \u0026#39;叶平\u0026#39;; ); 48、查询两门以上不及格课程的同学的学号及其平均成绩 SELECT Sid , AVG(Score) FROM SC WHERE Score \u0026lt; 60 GROUP BY Sid HAVING COUNT(*) \u0026gt; 2 49、检索“004”课程分数小于60，按分数降序排列的同学学号 SELECT Sid FROM SC WHERE SC.Score \u0026lt; 60 AND SC.Cid = \u0026#34;004\u0026#34; ORDER BY Score DESC; 50、删除“002”同学的“001”课程的成绩 DELETE From Course WHERE Sid = \u0026#34;002\u0026#34; AND Cid = \u0026#39;001\u0026#39; ","date":"2021-05-20T14:49:56+08:00","image":"https://minezeratul.github.io/p/mysql-learning/head_hu7ce4f066287f8312f26249d9427cec69_784954_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/mysql-learning/","title":"SQLPratice"},{"content":"Find the Kth-frequency word 这是5.19 的 692. 前K个高频单词\n用哈希表 + 排序， HashMap记录次数 , 然后从大到小排列 public static List\u0026lt;String\u0026gt; topKFrequent(String[] words, int k) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (String word : words) { map.put(word, map.getOrDefault(word, 0) + 1); } for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { ans.add(entry.getKey()); } Collections.sort(ans, new Comparator\u0026lt;String\u0026gt;() { //compare\u0026gt;0则大在前 \u0026lt;0则大在后  //compareTo 比较两个str  @Override public int compare(String o1, String o2) { return map.get(o1).equals(map.get(o2)) ? o1.compareTo(o2) : map.get(o2) - map.get(o1); } }); return ans.subList(0, k); } 用 哈希表 + java pq , 最小堆去除 public static List\u0026lt;String\u0026gt; topKFrequent(String[] words, int k) { List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String word : words) { map.put(word, map.getOrDefault(word, 0) + 1); } PriorityQueue\u0026lt;Map.Entry\u0026lt;String, Integer\u0026gt;\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(new Comparator\u0026lt;Map.Entry\u0026lt;String, Integer\u0026gt;\u0026gt;() {//同样利用Comparator 进行比较  @Override public int compare(Map.Entry\u0026lt;String, Integer\u0026gt; o1, Map.Entry\u0026lt;String, Integer\u0026gt; o2) { return o1.getValue().equals(o2.getValue()) ? o2.getKey().compareTo(o1.getKey()) : o1.getValue() - o2.getValue(); } }); for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { pq.offer(entry); if (pq.size() \u0026gt; k) { pq.poll(); } } while (!pq.isEmpty()) { ans.add(pq.poll().getKey()); } Collections.reverse(ans);//逆序  return ans; } ","date":"2021-05-19T10:32:16+08:00","image":"https://minezeratul.github.io/p/kth/wallhaven-kww621_hu372b036221b09c8e585f89078ca6399d_640712_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/kth/","title":"You hava my word now"},{"content":"Leetcode 1442 5.18的每日一题1442. 形成两个异或相等数组的三元组数目\na = arr[i] ^ arr[i + 1] ^ \u0026hellip; ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ \u0026hellip; ^ arr[k\n利用了x^y = 0 ，可知两个数必相等。计算每个数的异或 ， 若出现0 ， 则说明该区间有能够令 a == b 成立的三元组 (i, j , k) 的数目\n其实 i ^ k = 0 , i \u0026lt; j \u0026lt;= k , j在区间范围内，异或结果都等于0\nTalk is cheap , show u the code XDDDD\npublic int countTriplets(int[] arr) { int n = arr.length; int ans = 0; //int[] s = new int[n + 1];  //for (int i = 0; i \u0026lt; n; ++i) {  // s[i + 1] = s[i] ^ arr[i];  //} 官解用了[前缀异或]的方法来解答  for (int i = 0; i \u0026lt; n; i++) { int sum = 0; for (int k = i ; k \u0026lt; n ; k++){ sum ^= arr[k]; if (sum == 0)//if(s[i] == s[k + 1]) 即有三元区间 使得结果=0  ans += (k - i); } } return ans; } 时间复杂度：O(n)\n空间复杂度：O(n)\n","date":"2021-05-18T19:32:07+08:00","image":"https://minezeratul.github.io/p/eleventh-blog/wallhaven-wq1o8p_hufcd2f25bc6dea744efafee36c63d9ed8_1117287_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/eleventh-blog/","title":"又又又是XOR"},{"content":"Leetcode 993 5.17的每日一题993. 二叉树的堂兄弟节点\n同深度 ， 不同父节点 就可判断\n直接dfs查找，若不存在，返回null\n不在第n层就继续往下走\npublic class isCousins993 { TreeNode parX; TreeNode parY; int deepX; int deepY; public boolean isCousins(TreeNode root, int x, int y) { dfs(root, null, 0, x, y); return parX != parY \u0026amp;\u0026amp; deepX == deepY; } private void dfs(TreeNode root, TreeNode par, int deep, int x, int y) { if (root == null) return; if (root.val == x) { deepX = deep; parX = par; } else if (root.val == y) { deepY = deep; parY = par; } else { dfs(root.left, root, deep + 1, x, y); dfs(root.right, root, deep + 1, x, y); } } } ","date":"2021-05-17T10:43:19+08:00","image":"https://minezeratul.github.io/p/tenth-blog/wallhaven-rdg3dm_hucaf993a63a550e009a6d2190b51b5980_274278_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/tenth-blog/","title":"Are u my cousin?"},{"content":"Leetcode 421 FineMaxXOR 5.16的题目 421. 数组中两个数的最大异或值\n用到了 208. 实现 Trie (前缀树) algs4的chapter5.2\npublic class Trie { private Trie[] children; private boolean isEnd; public Trie() { children = new Trie[26];//字母表映射  isEnd = false; } //插入字符串 \t//我们从字典树的根开始,插入字符串。对于当前字符对应的子节点,有两种情况 \t//子节点存在。沿着指针移动到子节点,继续处理下一个字符。 \t//子节点不存在。创建一个新的子节点,记录在children数组的对应位置上,  //然后沿着指针移动到子节点,继续搜索下一个字符。  public void insert(String word) { Trie node = this;//root  for (int i = 0; i \u0026lt; word.length(); i++) { char ch = word.charAt(i); int index = ch - \u0026#39;a\u0026#39;; if (node.children[index] == null) node.children[index] = new Trie(); node = node.children[index]; } node.isEnd = true; } public boolean search(String word) { Trie node = searchPrefix(word); return node != null \u0026amp;\u0026amp; node.isEnd; } public boolean startsWith(String prefix) { return searchPrefix(prefix) != null; } //查找前缀 \t//我们从字典树的根开始,查找前缀。对于当前字符对应的子节点,有两种情况 \t//子节点存在:沿着指针移动到子节点,继续搜索下一个字符,直到isEnd = true \t//子节点不存在:说明字典树中不包含该前缀,返回null。  private Trie searchPrefix(String prefix) { Trie node = this; for (int i = 0; i \u0026lt; prefix.length(); i++) { char ch = prefix.charAt(i); int index = ch - \u0026#39;a\u0026#39;; if (node.children[index] == null) return null; node = node.children[index]; } return node; } } \rTrie tree\r\n421则是用了Trie的方法来做\nclass Solution { // 字典树的根节点  Trie root = new Trie(); // 最高位的二进制位编号为 30  static final int HIGH_BIT = 30; public int findMaximumXOR(int[] nums) { int n = nums.length; int x = 0; for (int i = 1; i \u0026lt; n; ++i) { // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中  add(nums[i - 1]); // 将 nums[i] 看作 a_i，找出最大的 x 更新答案  x = Math.max(x, check(nums[i])); } return x; } public void add(int num) { Trie cur = root; for (int k = HIGH_BIT; k \u0026gt;= 0; --k) { int bit = (num \u0026gt;\u0026gt; k) \u0026amp; 1; if (bit == 0) { if (cur.left == null) { cur.left = new Trie(); } cur = cur.left; } else { if (cur.right == null) { cur.right = new Trie(); } cur = cur.right; } } } //尽可能找异位 , 0 ⊕ 1 = 1 , 使得值为最大  public int check(int num) { Trie cur = root; int x = 0; for (int k = HIGH_BIT; k \u0026gt;= 0; --k) { int bit = (num \u0026gt;\u0026gt; k) \u0026amp; 1; if (bit == 0) { // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走  if (cur.right != null) { cur = cur.right; x = x * 2 + 1; } else { cur = cur.left; x = x * 2; } } else { // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走  if (cur.left != null) { cur = cur.left; x = x * 2 + 1; } else { cur = cur.right; x = x * 2; } } } return x; } } } class Trie { Trie left = null;//0  Trie right = null;//1 } ","date":"2021-05-16T23:21:51+08:00","image":"https://minezeratul.github.io/p/ninth-blog/wallhaven-z8p1jy_hu38044c2a6d833b8cc715b17eaec2c4bb_307896_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/ninth-blog/","title":"Trie \u0026 XOR"},{"content":"Leetcode 740 5.5的题目740. 删除并获得点数 和 198. 打家劫舍 有点类似 , 需要在一些地方做出调整\n为了做740，先去当了一遍小偷XDDD\n打家劫舍，经典dp问题，偷还得隔间偷,甚至开了透视知道哪里最多钱（笑\n一间的时候肯定只能偷那个，两间的时候就需要Math.max比较\nn间的时候则需要 when i \u0026gt; 2 , Math.max(dp[i - 2] + num[i] , dp[i - 1])来比较金额大小\npublic int rob(int[] nums) { int n = nums.length; if (n == 0 || nums == null) return 0; else if (n == 1) return nums[0]; /** int[] dp = new int[n]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i \u0026lt; n; i++) { dp[i] = Math.max(dp[i - 2] + nums[i] , dp[i -1]); } return dp[n - 1]; */ //最大金额只与前两间房子的最大值相关  //用滚动数组优化  int first = nums[0], second = Math.max(nums[0], nums[1]); for (int i = 2; i \u0026lt; n; i++) { int temp = second; second = Math.max(first + nums[i], second); first = temp; } return second; } 时间复杂度：O(n) ， 需要对整个num数组遍历一次\n空间复杂度：O(1)，不需要存储每次计算结果\n 740的话，需要先找出最大值max , 因为需要用一个all数组来记录相同元素之和 , 防止out of bound\n/** * 根据题意,在选择了元素x后,该元素以及所有等于x-1或x+1的元素会从数组中删去。 * 若还有多个值为x的元素,由于所有等于x-1或x+1的元素已经被删除,我们可以直接删除并获得其点数。 * 因此若选择了x,所有等于x的元素也应同被选择,以尽可能多地获得点数。 */ public int deleteAndEarn(int[] nums){ int n = nums.length; if (n == 0 || nums == null) return 0; else if (n == 1) return nums[0]; int max = 0; for (int maxVal:nums) { max = Math.max(maxVal , max);//防止out of bounds  } int[] all = new int[max + 1]; for (int val : nums) all[val] += val; return rob(all); } private int rob(int[] nums){ int n = nums.length; int first = nums[0] , second = Math.max(nums[0] , nums[1]); for (int i = 2; i \u0026lt; n; i++) { int temp = second; second = Math.max(first + nums[i], second); first = temp; } return second; } 时间复杂度O(N+M) , 其中N是数组nums的长度, M是num中元素的最大值。\n空间复杂度:O(M)\n","date":"2021-05-16T00:47:24+08:00","image":"https://minezeratul.github.io/p/eighth-blog/wallhaven-3zqdjv_hua3d208be2a18f6c69f0bc48a70d7f9db_2862984_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/eighth-blog/","title":"Rob me if u can"},{"content":"Leetcode 1482 这是5.9号的题目 1482. 制作 m 束花所需的最少天数\n二分的应用场景不一定有序，只要具备排他性、两段性，就可以二分\n寻找最优临界值的题目，往往可以借助二分搜索\n/** * @param bloomDay 什么时候开花 * @param m m束 * @param k k朵花做成一束 * @return */ public static int minDays(int[] bloomDay, int m, int k) { int n = bloomDay.length; if (n \u0026lt; m * k)//不够花束  return -1; int low = Integer.MAX_VALUE, high = 0; for (int i = 0; i \u0026lt; n; i++) { low = Math.min(low, bloomDay[i]);//找到最小值作为low  high = Math.max(high, bloomDay[i]);//找到最大值作为high  } while (low \u0026lt; high) {//不断靠近目标值,当low = high时，此时即为最少天数  int days = (high - low) / 2 + low; if (canMake(bloomDay, days, m, k)) { high = days; } else { low = days + 1; } } return low; } //辅助函数，找到临界点  public static boolean canMake(int[] bloomDay, int days, int m, int k) { //在确保可以制作出指定数量的花束的情况下，所需的最少天数一定会大于min，小于max  //days很小的时候，总是返回false，不够做够花束，而days很大的时候，则总是返回true  int bouquets = 0; int flowers = 0; int length = bloomDay.length; for (int i = 0; i \u0026lt; length \u0026amp;\u0026amp; bouquets \u0026lt; m; i++) { if (bloomDay[i] \u0026lt;= days) { flowers++; if (flowers == k) { bouquets++; flowers = 0; } } else { flowers = 0; } } return bouquets \u0026gt;= m; }\t","date":"2021-05-15T20:47:24+08:00","image":"https://minezeratul.github.io/p/seventh-blog/wallhaven-v9qy9l_huf424ae543613049e9d1957ffc0ce99c4_1243068_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/seventh-blog/","title":"minDays 1482"},{"content":"Leetcode 12 and Leetcode 13 5.14和5.15的每日一题 ，貌似没有什么可写的，可能就需要用StringBuilder来构建string\n12. 整数转罗马数字 class Solution { public String intToRoman(int num) { StringBuilder sb = new StringBuilder(); int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; for (int i = 0; i \u0026lt; values.length; i++) { int val = values[i]; while (num \u0026gt;= val){ num -= val; sb.append(getStr(val)); if (num == 0) break; } } return sb.toString(); } private String getStr(int num){ switch (num){ case 1000: return \u0026#34;M\u0026#34;; case 900: return \u0026#34;CM\u0026#34;; case 500: return \u0026#34;D\u0026#34;; case 400: return \u0026#34;CD\u0026#34;; case 100: return \u0026#34;C\u0026#34;; case 90: return \u0026#34;XC\u0026#34;; case 50: return \u0026#34;L\u0026#34;; case 40: return \u0026#34;XL\u0026#34;; case 10: return \u0026#34;X\u0026#34;; case 9: return \u0026#34;IX\u0026#34;; case 5: return \u0026#34;V\u0026#34;; case 4: return \u0026#34;IV\u0026#34;; case 1: return \u0026#34;I\u0026#34;; } return null; } } 13. 罗马数字转整数 public int romanToInt(String s) { int count = 0; int size = s.length(); for (int i = 0; i \u0026lt; size; i++) { if (i + 1 == size) count += getVal(s.charAt(i)); else { if (getVal(s.charAt(i + 1)) \u0026lt;= getVal(s.charAt(i))) count += getVal(s.charAt(i)); else { count += getVal(s.charAt(i + 1)) - getVal(s.charAt(i)); i++; } } } return count; } public int getVal(char ch) { switch (ch) { case \u0026#39;I\u0026#39;: return 1; case \u0026#39;V\u0026#39;: return 5; case \u0026#39;X\u0026#39;: return 10; case \u0026#39;L\u0026#39;: return 50; case \u0026#39;C\u0026#39;: return 100; case \u0026#39;D\u0026#39;: return 500; case \u0026#39;M\u0026#39;: return 1000; default: return 0; } } ","date":"2021-05-15T00:00:00+08:00","image":"https://minezeratul.github.io/p/6th-blog/wallhaven-rdqvpq_hu4a0c1228b7c9baee4eb7cca01158b3ad_537850_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/6th-blog/","title":"intToRoman and RomanToInt"},{"content":"Leetcode 307 这是今天做的一个题 307. 区域和检索 - 数组可修改\n和 303. 区域和检索 - 数组不可变 不同的是 数组可修改\n上一个dalao的分析 , 放弃996了\n/** * 数组不变，求区间和：「前缀和」、「树状数组」、「线段树」 * * 多次修改某个数，求区间和：「树状数组」、「线段树」 * * 多次整体修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间的数据范围） * * 多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间的数据范围） * */ 学了个树状数组方法。\nclass NumArray { int[] tree; int lowBits(int x){ return x \u0026amp; -x;//保留二进制下最后出现的1的位置，其余位置置0  } //当一个偶数与它的负值向与时，结果是能被这个偶数整除的最大的2的n次幂 , 比如10返回2  //当一个奇数与它的负值向与时结果一定是1  // 查询前缀和的方法  int query(int x){ int ans = 0; for (int i = x; i \u0026gt; 0 ; i -= lowBits(i)) { ans += tree[i]; } return ans; } // 在树状数组 x 位置中增加值 u  void add(int x ,int u){ for (int i = x; i \u0026lt;= n ; i += lowBits(i)) { tree[i] += u; } } int[] nums; int n; // 初始化「树状数组」  public NumArray(int[] nums) { this.nums = nums; n = nums.length; tree = new int[n + 1]; for (int i = 0; i \u0026lt; n; i++) { add(i + 1, nums[i]); } } // 原有的值是 nums[i]，要使得修改为 val，需要增加 val - nums[i]  public void update(int index, int val) { add(index + 1 , val - nums[index]); nums[index] = val; } public int sumRange(int left, int right) { return query(right + 1) - query(left); } } ","date":"2021-05-13T00:00:00+08:00","image":"https://minezeratul.github.io/p/5th-blog/wallhaven-nkd6x6_hu91ef828cf299bfb62d37d6673a920b75_286363_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/5th-blog/","title":"NumArray307"},{"content":"Leetcode 1310 今天又是爆肝的一天 , 感觉这个月应该 是异或月了，全是异或题（痛哭）\n今天的每日一题是1310. 子数组异或查询\nqueries数组提供的是查询的范围\n然后返回一个包含所有查询结果的数组\n我们可以用类似 prefix sum 前缀和\n采取 prefix XOR前缀异或 来完成该题\n对于每个查询都要计算，因此我们应该优化每个查询的计算时间\nqueries(L , R)\n= array[L] ⊕ \u0026hellip;. ⊕ array[R] , 又 x ⊕ x = 0\n= ( array[0] ⊕ \u0026hellip;. ⊕ array[L - 1] ) ⊕ ( array[0] ⊕ \u0026hellip;. ⊕ array[L - 1] ) ⊕ ( array[L] ⊕ \u0026hellip;. ⊕ array[R] )\n= ( array[0] ⊕ \u0026hellip;. ⊕ array[L - 1] ) ⊕ ( array[0] ⊕ \u0026hellip;. ⊕ array[R] )\n= XORS[L] ⊕ XORS[R + 1]\nXORS为存储 前缀异或 的数组 , 当L = 0时，XORS[0] = 0 ，以上等式仍然成立\n数组不变，求区间 , 都可以用prefix来解决\n public static int[] xorQueries(int[] arr, int[][] queries) { int n = arr.length; int[] pre = new int[n + 1]; //计算每个位置的前缀和 pre[i] 表示前i项的异或和  for (int i = 1; i \u0026lt;= n; i++) { pre[i] = pre[i - 1] ^ arr[i - 1]; } int[] ans = new int[queries.length]; int i = 0; /** * for (int i = 0; i \u0026lt; m; i++) { * ans[i] = xors[queries[i][0]] ^ xors[queries[i][1] + 1]; * } */ for (int[] query : queries) { //前面多异或的部分，再重复异或一次就可以抵消了  //假设 求 [1, 2]，那么对于 [0, 2] 来说就是多异或了 [0, 0] 这个结果  //根据 两个相同值异或结果为 0，那么我们可以再异或一次 [0, 0] 就将 [0, 0] 给抵消掉了  //pre[query[0]]代表了[0, 0]异或 pre[query[1] + 1]代表了[0, 2]异或 其中[0, 0]异或两次  //最后相当于[1, 2]异或  ans[i++] = pre[query[0]] ^ pre[query[1] + 1]; } return ans; } 时间复杂度：O(n+m) , n , m 分别为array , queries数组的长度\n空间复杂度：O(n)\n类似题目有307. 区域和检索 - 数组可修改\n","date":"2021-05-12T18:40:29+08:00","image":"https://minezeratul.github.io/p/4th-blog/wallhaven-281d5y_hue3cb4f8324f5bc5c464a88daae21375e_3477426_120x120_fill_box_smart1_2.png","permalink":"https://minezeratul.github.io/p/4th-blog/","title":"xorQueries"},{"content":"Leetcode 872 Hello , 我是mz\n这是今天的每日一题872. 叶子相似的树\n题目要求获取这些叶子的值并按从左到右的顺序排列形成一个 叶值序列\n叶 ， 即无左右节点 , 并且还有按顺序，我们可以选择用中序遍历来完成要求\npublic boolean leafSimilar(TreeNode root1, TreeNode root2) { List\u0026lt;Integer\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); inorder(root1, list1); inorder(root2, list2); return list1.equals(list2); } private void inorder(TreeNode root, List\u0026lt;Integer\u0026gt; list) { if (root != null) { inorder(root.left, list); if (root.left == null \u0026amp;\u0026amp; root.right == null) list.add(root.val); inorder(root.right, list); } } 空间复杂度为O（n + m) ，n , m 分别为两个ArrayList\n需要遍历整个list ，因此时间复杂度为O（n + m)\n","date":"2021-05-08T00:00:00+08:00","image":"https://minezeratul.github.io/p/third-blog/wallhaven-5we787_hu30910665284931ace4f57faa1e01d828_921583_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/third-blog/","title":"leaf Similar"},{"content":"Leetcode 554 大家好，我是mz\n这是2021.5.2的每日一题554. 砖墙\n题目要求一条自顶向下 的、穿过 最少 砖块的垂线 ， 也可以理解为 总行数- 间隙最多\n这样就可以得出穿过最少砖块的路线\n我选择用了 [哈希表] 去记录了每个间隙所生成的位置 , 然后用Math.max去寻找最大间隙.\npublic int leastBricks(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; wall) { Map\u0026lt;Integer , Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (List\u0026lt;Integer\u0026gt; widths:wall){ int n = widths.size(); int sum = 0; for (int i = 0; i \u0026lt; n - 1; i++) { sum += widths.get(i); map.put(sum , map.getOrDefault(sum , 0) + 1);//记录间隙位置  } } int cnt = 0; for (Map.Entry\u0026lt;Integer , Integer\u0026gt; entry : map.entrySet()){\tcnt = Math.max(cnt , entry.getValue());//对比间隙  } return wall.size() - cnt; } 时间复杂度：O(nm) nn 是砖墙的高度，mm 是每行砖墙的砖的平均数量\n空间复杂度：O(nm)\n","date":"2021-05-08T00:00:00+08:00","image":"https://minezeratul.github.io/p/second-blog/wallhaven-pk8pzj_hu3d2822634ca48e852ce9c18a25e720d4_8322172_120x120_fill_box_smart1_2.png","permalink":"https://minezeratul.github.io/p/second-blog/","title":"Least Bricks"},{"content":"Hello , This is my first blog here I\u0026rsquo;m Minezeratul 今天的每日一题为 1486. 数组异或操作\n异或操作 , 即为XOR ， 同为0 ，异为1 ，1^0 = 1 0^0 = 0\nif (n == 1)//当为1的时候不运算  return start; int res = 0 ; for (int i = 0; i \u0026lt; n; i++) { res ^= start + 2 * i;//直接循环运算 } return res; 时间复杂度为O(n)\n","date":"2021-05-07T00:00:00+08:00","image":"https://minezeratul.github.io/p/first-blog/wallhaven-x8ev3l_hu5438825b9b6d1014226d20d231e650c2_680482_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/first-blog/","title":"My First Blog here"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n 图片 \rPhoto by Florian Klauer on Unsplash\r \rPhoto by Luca Bravo on Unsplash\r\n\rPhoto by Helena Hertz on Unsplash\r \rPhoto by Hudai Gayiran on Unsplash\r\n![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://minezeratul.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","image":"https://minezeratul.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }","date":"2019-03-05T00:00:00Z","image":"https://minezeratul.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/emoji-support/","title":"Emoji Support"}]