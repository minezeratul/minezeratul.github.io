[{"content":"股票问题 我们需要注意的是交易次数k的限制\n 121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/) 股票入门题目  只有一次交易机会，我们只需要找到最小价格日和最大价格日即可解决问题\n //交易次数k的限制  //k = 1 public int maxProfit(int[] prices) { int n = prices.length; int profit = 0, buy = prices[0]; for (int i = 1; i \u0026lt; n; i++) { profit = Math.max(profit, prices[i] - buy); buy = Math.min(buy, prices[i]); } return profit; } 122. 买卖股票的最佳时机 II  122则可以进行多次交易，我们需要用dp状态机来解决问题\n   dp[i][0]表示未持有股票\n  dp[i][1]表示持有股票\ndp[i][0]状态则从前一天的(未持有 ，持有卖出)转移 ,\ndp[i][1]状态则从前一天的(持有，未持有买入)转移\n  //k = +infinity \tpublic int maxProfitDP(int[] prices) { int n = prices.length; int[][] dp = new int[n][2]; dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); } return dp[n - 1][0]; } //对二维dp进行优化 \t//每一天的情况只与前一天的有关  public int maxProfit_k_inf(int[] prices){ int n = prices.length; if (n == 0){ return 0; } int dp0 = 0, dp1 = -prices[0]; for (int price : prices) { dp0 = Math.max(dp0, dp1 + price); dp1 = Math.max(dp1, dp0 - price); } return dp0; } //我们注意到题目要求也符合贪心算法 \t//Greedy  public int maxProfit(int[] prices) { //只要有赚就卖  int n = prices.length; int profit = 0; for (int i = 1; i \u0026lt; n; i++) { profit += Math.max(0, prices[i] - prices[i - 1]); } return profit; } 714. 买卖股票的最佳时机含手续费  无限次交易，需计算手续费进行判断\n 我们只需在121的基础上进行修改就好\n//k with fee  public int maxProfit_k_fee(int[] prices , int fee){ int n = prices.length; int profit = 0, buy = -prices[0]; for (int i = 1; i \u0026lt; n; i++) { profit = Math.max(profit, prices[i] + buy - fee); buy = Math.max(buy, profit - prices[i]); } return profit; } 309. 最佳买卖股票时机含冷冻期  每次交易后都会有一天的冷冻期才可以进行下一次交易，即有三种状态：未持有，冷冻期，持有\n 用dp状态机去解决不同0 / 1 / 2三种情况\npublic int maxProfit(int[] prices) { int n = prices.length; if (n == 0) { return 0; } //0:持股，1:卖出进入CD, 2:不持股且不CD  int[][] dp = new int[n][3]; dp[0][0] = -prices[0]; for (int i = 1; i \u0026lt; n; i++) { //买入，前者是状态1持股未卖出 ， 后者是处于状态2的时候准备卖出  dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]); //今天卖了，收益是↓  dp[i][1] = dp[i - 1][0] + prices[i]; //dp[i - 1][1]股票之前就卖掉了，前一天是冷冻期 , 后者则是之前卖了且前一天不在CD  dp[i][2] = Math.max(dp[i - 1][1], dp[i - 1][2]); } return Math.max(dp[n - 1][1], dp[n - 1][2]); } //优化 \t//k with cooldown  public int maxProfit_k_cd(int[] prices){ int n = prices.length; if (n == 0){ return 0; } //dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])  //dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])  //dp[i][]只与dp[i - 1][]有关 ， 用pre去代替  int dp_i_0 = 0 , dp_i_1 = Integer.MIN_VALUE , dp_pre_0 = 0; for (int price : prices) { int tmp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + price); dp_i_1 = Math.max(dp_i_1, dp_pre_0 - price); dp_pre_0 = tmp; } return dp_i_0; } ","date":"2021-09-29T11:20:07+08:00","image":"https://minezeratul.github.io/p/stock/wallhaven-y8vlyk_hueebd90610263ab0b781ac2a0552f19ae_626008_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/stock/","title":"Stocks股票问题"},{"content":"backtrack 回溯算法 先做决定，然后撤回 , 就是一个决策树的遍历 需要注意的有三个问题   路径\n  选择\n  终止条件\n伪码如下:\npublic void backtrack(路径，选择列表){ if (终止条件){ add(路径)； return; } for 选择 in 列表 { 做选择； backtrack(路径，选择列表); 撤回； } }   而且不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高\n 46. 全排列 题目要求不含重复数字，所以我们还需要注意不符合的选择 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums){ LinkedList\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); backtrack(nums , track); return res; } private void backtrack(int[] nums, LinkedList\u0026lt;Integer\u0026gt; track) { // 触发结束条件  if (track.size() == nums.length) { res.add(new LinkedList(track)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { // 排除不合法的选择  if (track.contains(nums[i])) continue; // 做选择  track.add(nums[i]); // 进入下一层决策树  backtrack(nums, track); // 取消选择  track.removeLast(); } } } 47. 全排列 II 而在47中，是包含了重复数字 class Solution { boolean[] record; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new LinkedList\u0026lt;\u0026gt;(); public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permuteUnique(int[] nums) { int n = nums.length; if (n == 0){ return ans; } //剪枝前需排序  Arrays.sort(nums); LinkedList\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); record = new boolean[n]; backtrack(nums , track); return ans; } private void backtrack(int[] nums , LinkedList\u0026lt;Integer\u0026gt; list){ if (nums.length == list.size()){ ans.add(new LinkedList\u0026lt;\u0026gt;(list)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (record[i]){ continue; } //剪枝，!record[i - 1]为顺序剪枝，record[i - 1]为倒序剪枝  if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; !record[i - 1]) { continue; } record[i] = true; list.add(nums[i]); backtrack(nums , list); record[i] = false; list.removeLast(); } } } ","date":"2021-09-06T15:13:44+08:00","image":"https://minezeratul.github.io/p/permute/wallhaven-e7ek7k_hu42f09a73a6b436c194da493416605d94_263041_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/permute/","title":"Backtrack回溯 全排列"},{"content":"Leetcode 130 很多使用 DFS 深度优先算法解决的问题，也可以用 Union-Find 算法解决 Leetcode130，题目要求找出被X包围的O ，其中不包括边界上的O 第一种方法，用dfs 做法和官解一样\npublic void dfs(char[][] board){ int n = board.length; if (n == 0){ return; } //n为行数,m为列数  int m = board[0].length; //找出左右边界上的O，改为A  for (int i = 0; i \u0026lt; n; i++) { dfs(board , i , 0); dfs(board , i , m - 1); } //找出上下边界的O改为A  for (int i = 1; i \u0026lt; m - 1; i++) { dfs(board , 0 , i); dfs(board , n - 1 , i); } //遍历  for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { if (board[i][j] == \u0026#39;A\u0026#39;){ board[i][j] = \u0026#39;O\u0026#39;; }else if (board[i][j] == \u0026#39;O\u0026#39;){ board[i][j] = \u0026#39;X\u0026#39;; }else { continue; } } } } //若找到边界上的O，开始上下左右搜索  //将邻接的O也变成A  public c void dfs(char[][] board , int x , int y){ //越界处理，以及寻O  if (x \u0026lt; 0 || y \u0026lt; 0 || x \u0026gt;= board.length || y \u0026gt;= board[0].length || board[x][y] != \u0026#39;O\u0026#39;){ return; } board[x][y] = \u0026#39;A\u0026#39;; //上下左右搜索  dfs(board , x + 1 , y); dfs(board , x - 1 , y); dfs(board , x , y + 1); dfs(board , x , y - 1); } 第二种方法，并查集 这里我们利用到了一个小技巧： 二维坐标 (x,y) 可以转换成 x * n + y Union-Find类写在了Union-Find public void solve(char[][] board) { if (board.length == 0){ return; } int m = board.length; int n = board[0].length; UnionFind uf = new UnionFind(m * n + 1); //虚构一个节点去连接  int dummy = m * n ; //将首列和末列的O与dummy连接  for (int i = 0; i \u0026lt; m; i++) { if (board[i][0] == \u0026#39;O\u0026#39;){ uf.union(i * n , dummy); } if (board[i][n - 1] == \u0026#39;O\u0026#39;){ uf.union(i * n + n - 1 , dummy); } } // 将首行和末行的 O 与 dummy 连通  for (int j = 0; j \u0026lt; n; j++) { if (board[0][j] == \u0026#39;O\u0026#39;) { uf.union(j, dummy); } if (board[m - 1][j] == \u0026#39;O\u0026#39;) { uf.union(n * (m - 1) + j, dummy); } } // 方向数组 direction 是上下左右搜索的常用手法  int[][] direction = {{1,0}, {0,1}, {0,-1}, {-1,0}}; for (int i = 1; i \u0026lt; m - 1; i++) { for (int j = 1; j \u0026lt; n - 1; j++) { if (board[i][j] == \u0026#39;O\u0026#39;){ for (int k = 0; k \u0026lt; 4; k++) { int x = i + direction[k][0]; int y = j + direction[k][1]; if (board[x][y] == \u0026#39;O\u0026#39;) { uf.union(x * n + y , i * n + j); } } } } } //不和dummy连通的O，都要替换成X  for (int i = 1; i \u0026lt; m - 1; i++) { for (int j = 1; j \u0026lt; n - 1; j++) { if (!uf.connected(dummy , i * n + j)){ board[i][j] = \u0026#39;X\u0026#39;; } } } } ","date":"2021-07-21T20:44:50+08:00","image":"https://minezeratul.github.io/p/solve130/wallhaven-0q8rpl_hua4fa3d719de033e82f80e306080b98f9_68426_120x120_fill_box_smart1_2.png","permalink":"https://minezeratul.github.io/p/solve130/","title":"并查集Union-Find应用"},{"content":"Union-Find 并查集 Union-Find 并查集算法的关键在于union和connected的效率 ， 若只是简单的连接节点 **find , union , connected **三个函数的时间复杂度会是O(n) ，而通过平衡树，可使复杂度降低到O(logn) 再而通过路径压缩，可使得union和connected的时间复杂度达到O(1) 这是优化版的Union-Find , 防止了树退化成链表而降低了效率 public class UnionFind { private int count;//连通分量个数  private int[] parent;//存储一棵树 , 记录每个节点的父节点，相当于指向父节点的指针  private int[] size;//记录每棵树重量  public UnionFind() { } public UnionFind(int n) { this.count = n; parent = new int[n]; size = new int[n]; for (int i = 0; i \u0026lt; n; i++) { parent[i] = i;//节点指向自己  size[i] = 1; } } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) { return; } //get the balanced tree  // 将两棵树合并为一棵树，小树接到大树下面，较平衡  // 使其不会退化成链表而降低效率  if (size[rootP] \u0026gt; size[rootQ]) { parent[rootQ] = rootP; size[rootP] += size[rootQ]; } else { parent[rootP] = rootQ; size[rootQ] += size[rootP]; } count--; } private int find(int x) { //路径压缩  while (parent[x] != x) { parent[x] = parent[parent[x]]; x = parent[x]; } return x; } public boolean connected(int p, int q) { int rootP = find(p); int rootQ = find(q); return rootP == rootQ; } public int count() { return count; } } ","date":"2021-07-21T19:31:34+08:00","image":"https://minezeratul.github.io/p/unionfind/wallhaven-6o59k7_hu4159b3c77d519f83d7062c6d564bbeaa_1883045_120x120_fill_box_smart1_2.png","permalink":"https://minezeratul.github.io/p/unionfind/","title":"Union-Find"},{"content":"Graph Algorithms Part II. PrimMST 即时版本 用PriorityQueue存储vertex 详情可见algs4 4.3.5 不需要保存所有非树顶点w到树顶点的边，而只需要保存其中权重最小的那条，将v添加后检查是否需要更新这条权重最小的边\npublic MST getMinimumSpanningTree(int startingVertex) { List\u0026lt;Integer\u0026gt; T = new ArrayList\u0026lt;Integer\u0026gt;(); // T initially contains the startingVertex;  T.add(startingVertex); // Number of vertices  int numberOfVertices = vertices.size(); // Parent of a vertex  int[] parent = new int[numberOfVertices]; // Initially set the parent of all vertices to -1  Arrays.fill(parent, -1); // Total weight of the tree thus far  double totalWeight = 0; // Clone the priority queue, so to keep the original queue intact  List\u0026lt;PriorityQueue\u0026lt;WeightedEdge\u0026gt;\u0026gt; queues = deepClone(this.queues); // All vertices are found?  while (T.size() \u0026lt; numberOfVertices) { // Search for the vertex with the smallest edge adjacent to  // a vertex in T  int v = -1; double smallestWeight = Double.MAX_VALUE; for (int u : T) { while (!queues.get(u).isEmpty() \u0026amp;\u0026amp; T.contains(queues.get(u).peek().v)) { // Remove the edge from queues[u] if the adjacent  // vertex of u is already in T  queues.get(u).remove(); } if (!queues.get(u).isEmpty()) { // Current smallest weight on an edge adjacent to u  WeightedEdge edge = queues.get(u).peek(); if (edge.weight \u0026lt; smallestWeight) { v = edge.v; smallestWeight = edge.weight; // If v is added to the tree, u will be its parent  parent[v] = u; } } } // End of for  if (v != -1) { T.add(v); // Add a new vertex to the tree  totalWeight += smallestWeight; } else { break; // The tree is not connected, a partial MST is found  } } // End of while  return new MST(startingVertex, parent, T, totalWeight); } /** * Clone an array of queues */ private List\u0026lt;PriorityQueue\u0026lt;WeightedEdge\u0026gt;\u0026gt; deepClone(List\u0026lt;PriorityQueue\u0026lt;WeightedEdge\u0026gt;\u0026gt; queues) { List\u0026lt;PriorityQueue\u0026lt;WeightedEdge\u0026gt;\u0026gt; copiedQueues = new ArrayList\u0026lt;PriorityQueue\u0026lt;WeightedEdge\u0026gt;\u0026gt;(); for (int i = 0; i \u0026lt; queues.size(); i++) { copiedQueues.add(new PriorityQueue\u0026lt;WeightedEdge\u0026gt;()); for (WeightedEdge e : queues.get(i)) { copiedQueues.get(i).add(e); } } return copiedQueues; } Dijkstra , 用pq来存储vertex去实现 public ShortestPathTree getShortestPath(int sourceVertex) { // T stores the vertices whose path found so far  List\u0026lt;Integer\u0026gt; T = new ArrayList\u0026lt;Integer\u0026gt;(); // T initially contains the sourceVertex;  T.add(sourceVertex); // vertices is defined in AbstractGraph  int numberOfVertices = vertices.size(); // parent[v] stores the previous vertex of v in the path  int[] parent = new int[numberOfVertices]; parent[sourceVertex] = -1; // The parent of source is set to -1  // cost[v] stores the cost of the path from v to the source  double[] cost = new double[numberOfVertices]; for (int i = 0; i \u0026lt; cost.length; i++) { cost[i] = Double.MAX_VALUE; // Initial cost set to infinity  } cost[sourceVertex] = 0; // Cost of source is 0  // Get a copy of queues  List\u0026lt;PriorityQueue\u0026lt;WeightedEdge\u0026gt;\u0026gt; queues = deepClone(this.queues); // Expand T  while (T.size() \u0026lt; numberOfVertices) { int v = -1; // Vertex to be determined  double smallestCost = Double.MAX_VALUE; // Set to infinity  for (int u : T) { while (!queues.get(u).isEmpty() \u0026amp;\u0026amp; T.contains(queues.get(u).peek().v)) { queues.get(u).remove(); // Remove the vertex in queue for u  } if (!queues.get(u).isEmpty()) { WeightedEdge e = queues.get(u).peek(); if (cost[u] + e.weight \u0026lt; smallestCost) { v = e.v; smallestCost = cost[u] + e.weight; // If v is added to the tree, u will be its parent  parent[v] = u; } } } // End of for  if (v != -1) { T.add(v); // Add a new vertex to T  cost[v] = smallestCost; } else { break; // Graph is not connected, s cannot reach all vertices  } } // End of while  // Create a ShortestPathTree  return new ShortestPathTree(sourceVertex, parent, T, cost); } 第二种pq做法\npublic ShortestPathTree getShortestPath2(int sourceVertex) { // T stores the vertices whose path found so far  List\u0026lt;Integer\u0026gt; T = new ArrayList\u0026lt;Integer\u0026gt;(); // T initially contains the sourceVertex;  T.add(sourceVertex); // vertices is defined in AbstractGraph  int numberOfVertices = vertices.size(); // parent[v] stores the previous vertex of v in the path  int[] parent = new int[numberOfVertices]; // The parent of source is set to -1  parent[sourceVertex] = -1; // cost[v] stores the cost of the path from v to the source  double[] cost = new double[numberOfVertices]; Arrays.fill(cost, Double.MAX_VALUE); // Cost of source is 0  cost[sourceVertex] = 0; // Get a copy of queues  List\u0026lt;PriorityQueue\u0026lt;WeightedEdge\u0026gt;\u0026gt; queues = deepClone(this.queues); // Set cost for the neighbors of sourceVertex  // diff from method1  while (!queues.get(sourceVertex).isEmpty()) { WeightedEdge e = queues.get(sourceVertex).poll(); cost[e.v] = e.weight; parent[e.v] = sourceVertex; } // Expand T  while (T.size() \u0026lt; numberOfVertices) { // Find smallest cost v in V - T  int v = -1; // Vertex to be determined  double currentMinCost = Double.MAX_VALUE; for (int i = 0; i \u0026lt; getSize(); i++) { if (!T.contains(i) \u0026amp;\u0026amp; cost[i] \u0026lt; currentMinCost) { currentMinCost = cost[i]; v = i; } } if (v != -1) { T.add(v); // Add a new vertex to T  // Adjust cost[u] for u that is adjacent to v and u in V - T  while (!queues.get(v).isEmpty()) { WeightedEdge e = queues.get(v).poll(); if (!T.contains(e.v) \u0026amp;\u0026amp; cost[e.v] \u0026gt; cost[v] + e.weight) { cost[e.v] = cost[v] + e.weight; parent[e.v] = v; } } } else { break; // s cannot reach to all vertices  } } // End of while  // Create a ShortestPathTree  return new ShortestPathTree(sourceVertex, parent, T, cost); } ","date":"2021-07-20T09:24:47+08:00","image":"https://minezeratul.github.io/p/graph2/wallhaven-8oky1j_hu15f8624ba93dc5dbc7d7c54a2b0bed3b_1058803_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/graph2/","title":"Graph Algorithms Part II"},{"content":"Leetcode 451 451. 根据字符出现频率排序 利用hashmap记录 ， 或者用数组模拟hashmap , 然后利用PriorityQueue大顶堆来排序\npublic String frequencySort(String s) { StringBuilder sb = new StringBuilder(); //Map\u0026lt;Character , Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;();  //for (char ch : s.toCharArray()){  // map.put(ch , map.getOrDefault(ch , 0 ) + 1);  //}  //也可以开一个128的数组替换 , 优化性能  int[] frequency = new int[128]; for (char ch : s.toCharArray()){ frequency[ch]++; } PriorityQueue\u0026lt;node\u0026gt; pq = new PriorityQueue\u0026lt;node\u0026gt;((o1 , o2) -\u0026gt; o1.freq != o2.freq ? o2.freq - o1.freq : o1.ch - o2.ch); //for (char ch : map.keySet()){  // pq.offer(new node(ch , map.get(ch)));  //}  for (int i = 0; i \u0026lt; frequency.length; i++) { if (frequency[i] != 0){ pq.add(new node((char) (i) , frequency[i])); } } while (!pq.isEmpty()){ node poll = pq.poll(); int cnt = poll.freq; while (cnt-- \u0026gt; 0){ sb.append(poll.ch); } } return sb.toString(); } class node {//存储字符和频率  char ch; int freq; node(char ch , int freq){ this.ch = ch; this.freq = freq; } } ","date":"2021-07-06T15:33:26+08:00","image":"https://minezeratul.github.io/p/leetcode-451/wallhaven-j3e7j5_hudda1cf6777e9075b2d0686fd65b53af4_1985421_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/leetcode-451/","title":"String Freq Sort"},{"content":"Leetcode 645 FindErrorNum 645. 错误的集合 第一种方法，用数组模拟哈希表，获取出现次数\npublic int[] findErrorNums(int[] nums) { int n = nums.length; int[] res = new int[2];//导致集合丢失了一个数字 并且有一个数字重复。  int[] tmp = new int[n + 1]; for (int num : nums){ //统计次数  tmp[num]++; } for (int i = 1; i \u0026lt; tmp.length; i++) { if (tmp[i] == 1){ //有效  continue; } if (tmp[i] == 2){ //duplicated  res[0] = i; }else { //lost  res[1] = i; } } return res; } 第二种方法 ， 数学\n//第一个元素：重复元素 = 当前数组和 - 去重后的数组和 //第二个元素：缺失元素 = 数学1~n求和 - 去重后的数组和 public int[] findErrorNums2(int[] nums){ return new int[]{Arrays.stream(nums).sum() - Arrays.stream(nums).distinct().sum() , (1 + nums.length) * nums.length / 2 - Arrays.stream(nums).distinct().sum()}; } ","date":"2021-07-06T10:08:44+08:00","image":"https://minezeratul.github.io/p/leetcode-645/wallhaven-dp3yg3_hu9a39724aad0744ec345d914343dc7c46_216393_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/leetcode-645/","title":"FindErrorNum"},{"content":"Leetcode LCP-07 LCP 07. 传递信息 看用例就可以知道这是一个图，[u , v]\n用dfs深度优先来一步一步搜寻到末端\npublic int numWays(int n, int[][] relations, int k) { int cnt = 0; boolean[][] isVisited = new boolean[n][n];//判断是否经过  for (int[] relation : relations) { isVisited[relation[0]][relation[1]] = true; } return dfs(0 , isVisited , k); } public int dfs(int n , boolean[][] isVisited , int k){ if (k == 0){ return isVisited.length - 1 == n ? 1 : 0; } int cnt = 0 ; for (int i = 0; i \u0026lt; isVisited[n].length; i++) { if (isVisited[n][i]){//是则加1  cnt += dfs(i , isVisited , k - 1);//递归  } } return cnt; } ","date":"2021-07-05T16:15:12+08:00","image":"https://minezeratul.github.io/p/leetcode-lcp07/wallhaven-8okjz2_hu8c8c89a0a09d756b05c4d585d09b6e7b_5389260_120x120_fill_box_smart1_2.png","permalink":"https://minezeratul.github.io/p/leetcode-lcp07/","title":"Passing message"},{"content":"Leetcode 1833 1833. 雪糕的最大数量 夏天到了，终于放暑假了！LeetCode也叫人吃雪糕了\n由题意可知，要买最多雪糕，可以想出贪心\n第一种做法\npublic int maxIceCream(int[] costs, int coins) { int cnt = 0; Arrays.sort(costs);//sorted,从最便宜的开始买  for(int cost : costs){ if(coins \u0026gt;= cost){//超过即退出  coins -= cost; cnt++; }else{ break; } } return cnt; } 第二种排序，用计数排序来实现\npublic int maxIceCream2(int[] costs, int coins) { int[] freq = new int[100001]; for (int cost:costs){ //用数组模拟哈希表记录出现次数  freq[cost]++; } int cnt = 0; for (int i = 1; i \u0026lt;= 100000; i++) { if (coins \u0026gt;= i) {//超过即退出  int curCount = Math.min(freq[i], coins / i);//判断可以买多少支雪糕  cnt += curCount; coins -= i * curCount; } else { break; } } return cnt; } ","date":"2021-07-05T15:51:33+08:00","image":"https://minezeratul.github.io/p/leetcode-1833/wallhaven-q6d37d_hu908184025729ba5074dfa6dab9e3c75d_741173_120x120_fill_box_smart1_2.png","permalink":"https://minezeratul.github.io/p/leetcode-1833/","title":"Ice-Cream"},{"content":"Graph Algorithms Part I.2 小优化 用数组isTnT 代替contains()去查找一个顶点u是否在T里 MST public MST getMinimumSpanningTree(int startingVertex) { // cost[v] stores the cost by adding v to the tree  double[] cost = new double[getSize()]; // Initial cost  Arrays.fill(cost, Double.POSITIVE_INFINITY); cost[startingVertex] = 0; // Cost of source is 0  int[] parent = new int[getSize()]; // Parent of a vertex  parent[startingVertex] = -1; // startingVertex is the root  double totalWeight = 0; // Total weight of the tree thus far  List\u0026lt;Integer\u0026gt; T = new ArrayList\u0026lt;\u0026gt;(); boolean[] isTnT = new boolean[getSize()]; // Expand T  while (T.size() \u0026lt; getSize()) { // Find smallest cost v in V - T  int u = -1; // Vertex to be determined  double currentMinCost = Double.POSITIVE_INFINITY; for (int i = 0; i \u0026lt; getSize(); i++) { //!T.contains(i)  if (!isTnT[i] \u0026amp;\u0026amp; cost[i] \u0026lt; currentMinCost) { currentMinCost = cost[i]; u = i; } } isTnT[u] = true; T.add(u); // Add a new vertex to T  totalWeight += cost[u]; // Add cost[u] to the tree  // Adjust cost[v] for v that is adjacent to u and v in V - T  for (Edge e : neighbors.get(u)) { //!T.contains(e.v)  if (!isTnT[e.v] \u0026amp;\u0026amp; cost[e.v] \u0026gt; ((WeightedEdge) e).weight) { cost[e.v] = ((WeightedEdge) e).weight; parent[e.v] = u; } } } // End of while  return new MST(startingVertex, parent, T, totalWeight); } Dijkstra public ShortestPathTree getShortestPath(int sourceVertex) { // cost[v] stores the cost of the path from v to the source  double[] cost = new double[getSize()]; // Initial cost set to infinity  Arrays.fill(cost, Double.POSITIVE_INFINITY); cost[sourceVertex] = 0; // Cost of source is 0  // parent[v] stores the previous vertex of v in the path  int[] parent = new int[getSize()]; parent[sourceVertex] = -1; // The parent of source is set to -1  // T stores the vertices whose path found so far  List\u0026lt;Integer\u0026gt; T = new ArrayList\u0026lt;\u0026gt;(); boolean[] isTnT = new boolean[getSize()]; // Expand T  while (T.size() \u0026lt; getSize()) { // Find smallest cost v in V - T  int u = -1; // Vertex to be determined  double currentMinCost = Double.POSITIVE_INFINITY; for (int i = 0; i \u0026lt; getSize(); i++) { //!T.contains(i)  if (!isTnT[i] \u0026amp;\u0026amp; cost[i] \u0026lt; currentMinCost) { currentMinCost = cost[i]; u = i; } } isTnT[u] = true; T.add(u); // Add a new vertex to T  // Adjust cost[v] for v that is adjacent to u and v in V - T  for (Edge e : neighbors.get(u)) { //!T.contains(e.v)  if (!isTnT[e.v] \u0026amp;\u0026amp; cost[e.v] \u0026gt; cost[u] + ((WeightedEdge) e).weight) { cost[e.v] = cost[u] + ((WeightedEdge) e).weight; parent[e.v] = u; } } } // End of while  // Create a ShortestPathTree  return new ShortestPathTree(sourceVertex, parent, T, cost); } ","date":"2021-07-02T23:58:08+08:00","image":"https://minezeratul.github.io/p/graph1.2/wallhaven-vg36x3_hu391d8c48ccf48756e0894cf255dfd5e6_3941005_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/graph1.2/","title":"Graph Algorithms Part I.2"},{"content":"Reading Day  try-with-resources是jdk1.7引入的语法，使得关闭资源操作无需层层嵌套在finally\n 当try-finally关闭资源时，其出现了两处异常，往往只会返回第一处异常。\n当java7开始引入try-with-resources后，这些问题就迎刃而解了。不过使用这个结构的时候，必须接入AutoCloseable接口\n其中包括了单个返回void的close方法。现在Java库与第三方类库中的许多类和接口都实现了或拓展了AutoCloseable接口\nTry-Catch-Finally 结构 可见，我们需要手动关闭两个Stream资源。而且为了防止异常的产生而无法关闭，需要借助finally正常关闭资源\npublic class DemoTest { public static void main(String[] args) { BufferedInputStream bin = null; BufferedOutputStream bout = null; try { bin = new BufferedInputStream(new FileInputStream(new File(\u0026#34;test.txt\u0026#34;))); bout = new BufferedOutputStream(new FileOutputStream(new File(\u0026#34;out.txt\u0026#34;))); int b; while ((b = bin.read()) != -1) { bout.write(b); } } catch (IOException e) { e.printStackTrace(); } finally { if (bin != null) { try { bin.close(); } catch (IOException e) { throw e; } finally { if (bout != null) { try { bout.close(); } catch (IOException e) { throw e; } } } } } } } Try-with-resources结构 而在try-with-resources中，我们只需要这样，编译器会帮我们自动补全close()，并且还会将异常正确报出，而不会由于嵌\n套只指出一处异常。\npublic class TryWithResource { public static void main(String[] args) { try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File(\u0026#34;test.txt\u0026#34;))); BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File(\u0026#34;out.txt\u0026#34;)))) { int b; while ((b = bin.read()) != -1) { bout.write(b); } }catch (IOException e) { e.printStackTrace(); } } } 反编译class , 可见close()的补全\npublic class TryWithResource { public TryWithResource() { } public static void main(String[] args) { try { Connection conn = new Connection(); Throwable var2 = null; try { conn.sendData(); } catch (Throwable var12) { var2 = var12; throw var12; } finally { if (conn != null) { if (var2 != null) { try { conn.close(); } catch (Throwable var11) { var2.addSuppressed(var11); } } else { conn.close(); } } } } catch (Exception var14) { var14.printStackTrace(); } } } ","date":"2021-06-08T17:25:08+08:00","image":"https://minezeratul.github.io/p/note/wallhaven-3z32j3_hufe1b3409fa910156ba1dab10f6dbb05f_1637926_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/note/","title":"try-with-resources优先于try-finally"},{"content":"Graph Algorithms Part I. MST 最小生成树 public class MST extends Tree { private double totalWeight; // Total weight of all edges in the tree  public MST(int root, int[] parent, List\u0026lt;Integer\u0026gt; searchOrder, double totalWeight) { super(root, parent, searchOrder); this.totalWeight = totalWeight; } public double getTotalWeight() { return totalWeight; } } ShortestPathTree类 public class ShortestPathTree extends Tree{ private double[] cost; public ShortestPathTree(int source , int[] parent , List\u0026lt;Integer\u0026gt; searchOrder , double[] cost){ super(source , parent , searchOrder); this.cost = cost; } public double[] getCost() { return cost; } public void printAllPaths(){ System.out.println(\u0026#34;All shortest paths from \u0026#34; + vertices.get(getRoot()) + \u0026#34; are:\u0026#34;); for (int i = 0; i \u0026lt; cost.length; i++) { printPath(i); System.out.println(\u0026#34;(cost: \u0026#34; + cost[i] +\u0026#34;)\u0026#34;); } } } 1.Prim 最小生成树 , 即最小的总权重的生成树 public MST getMinSpanningTree(){ return getMinSpanningTree(0); } //包括了连通图里的所有顶点，  //且其所有边的权值之和亦为最小  //连通图足够密集时（当E满足Ω（VlogV）条件时），  //可较显著地提高运行速度。  //搜索到哪个edge权重最小就加入到T  public MST getMinSpanningTree(int sourceVertex) {//Algorithm Prim  double[] cost = new double[size()]; // cost[v] stores the cost by adding v to the tree  Arrays.fill(cost, Double.POSITIVE_INFINITY); cost[sourceVertex] = 0; int[] parent = new int[size()]; parent[sourceVertex] = -1; double totalWeight = 0; List\u0026lt;Integer\u0026gt; T = new ArrayList\u0026lt;\u0026gt;(); //boolean[] isTnT = new boolean[size()];  while (T.size() \u0026lt; size()){ int u = -1 ; double curMinCost = Double.POSITIVE_INFINITY; for (int i = 0; i \u0026lt; size(); i++) { if (!T.contains(i) \u0026amp;\u0026amp; cost[i] \u0026lt; curMinCost){ //我们可以用一个boolean数组来代替contains方法 : !isTnT[i]  //从而优化时间复杂度  //开始寻找最小值权重edge  curMinCost = cost[i]; u = i; } } // if (u == -1) break; else T.add(u);  //Add a new vertex to T  T.add(u); totalWeight += cost[u];//累加最小权重  //isTnT[u] = true;  for (Edge e:neighbors.get(u)){ if (!T.contains(e.v) \u0026amp;\u0026amp; cost[e.v] \u0026gt; ((MyWeightedEdge)e).weight){//adjust cost[v]  //对每个edge的权重进行比较，找出最小值  cost[e.v] = ((MyWeightedEdge)e).weight; parent[e.v] = u; } } } return new MST(sourceVertex , parent , T , totalWeight); //返回一个MST  } } 2.Kruskal 另一种寻找最小生成树算法 重复寻找最小总权重edge，若不出现环，则添加到树\n用了PriorityQueue去实现\npublic MST getMinimumSpanningTree() { WeightedGraph\u0026lt;V\u0026gt; t = new WeightedGraph\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; this.getSize(); i++) { t.addVertex(this.vertices.get(i)); } PriorityQueue\u0026lt;WeightedEdge\u0026gt; edgeList = getEdges(); double totalWeight = 0; while (!edgeList.isEmpty()) { WeightedEdge e = edgeList.remove(); t.neighbors.get(e.u).add(new WeightedEdge(e.u, e.v, e.weight)); t.neighbors.get(e.v).add(new WeightedEdge(e.v, e.u, e.weight)); if (t.getACycle() != null) { t.neighbors.get(e.u).remove(t.neighbors.get(e.u).size() - 1); t.neighbors.get(e.v).remove(t.neighbors.get(e.v).size() - 1); } else { totalWeight += e.weight; } } Tree tree = t.dfs(0); int[] parent = new int[vertices.size()]; for (int i = 0; i \u0026lt; parent.length; i++) { parent[i] = tree.getParent(i); } return new MST(tree.getRoot(), parent, tree.getSearchOrder(), totalWeight); } public PriorityQueue\u0026lt;WeightedEdge\u0026gt; getEdges() { PriorityQueue\u0026lt;WeightedEdge\u0026gt; list = new PriorityQueue\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; this.getSize(); i++) { for (Edge e : this.neighbors.get(i)) { if (e.u \u0026lt; e.v) { list.add((WeightedEdge) e); } } } return list; } public List\u0026lt;Integer\u0026gt; getACycle() { List\u0026lt;Integer\u0026gt; allVertices = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; this.vertices.size(); i++) { allVertices.add(i); } List\u0026lt;List\u0026lt;Edge\u0026gt;\u0026gt; neighbors = cloneEdges(); List\u0026lt;Integer\u0026gt; searchOrder = new ArrayList\u0026lt;\u0026gt;(); int[] parent = new int[vertices.size()]; // Initialize parent[i] to -1  Arrays.fill(parent, -1); // Mark visited vertices  boolean[] isVisited = new boolean[vertices.size()]; while (allVertices.size() \u0026gt; 0) { int v = allVertices.get(0); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); stack.push(v); searchOrder.add(v); allVertices.remove(new Integer(v)); isVisited[v] = true; // Vertex x visited  while (!stack.isEmpty()) { int x = stack.peek(); if (neighbors.get(x).size() == 0) { stack.pop(); } else { // Find the next unvisited neighbor of x  for (int i = neighbors.get(x).size() - 1; i \u0026gt;= 0; i--) { Edge e = neighbors.get(x).get(i); if (!isVisited[e.v]) { parent[e.v] = x; // The parent of vertex e.v is x  stack.push(e.v); // Add a new neighbor to the stack  isVisited[e.v] = true; // Vertex x visited  searchOrder.add(e.v); allVertices.remove(new Integer(e.v)); neighbors.get(x).remove(i); break; } else if (e.v != parent[x]) { // A path is found  List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(e.v); while (x != e.v) { list.add(x); x = parent[x]; } return list; } else { neighbors.get(x).remove(i); } } } } } return null; } public List\u0026lt;List\u0026lt;Edge\u0026gt;\u0026gt; cloneEdges() { List\u0026lt;List\u0026lt;Edge\u0026gt;\u0026gt; neigborCopy = new ArrayList\u0026lt;\u0026gt;(); for (List\u0026lt;Edge\u0026gt; neighbor : neighbors) { List\u0026lt;Edge\u0026gt; edges = new ArrayList\u0026lt;\u0026gt;(); for (Edge e : neighbor) { edges.add(e); } neigborCopy.add(edges); } return neigborCopy; } Union-Find并查集 实现Kruskal /** * @author Minezeratul */ public class KruskalUF { private Queue\u0026lt;WeightedEdge\u0026gt; mst; double weight; public KruskalUF(WeightedGraph G) { mst = new LinkedList\u0026lt;\u0026gt;(); PriorityQueue\u0026lt;WeightedEdge\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((Comparator.comparingDouble(o -\u0026gt; o.weight))); UnionFind uf = new UnionFind(G.getSize()); for (int i = 0; i \u0026lt; G.getSize(); i++) {//add all edges  for (int j = 0; j \u0026lt; G.getNeighbor(i).size(); j++) { pq.offer((WeightedEdge) G.getNeighbor(i).get(j)); } } while (!pq.isEmpty() \u0026amp;\u0026amp; mst.size() \u0026lt; G.getSize() - 1) { WeightedEdge e = pq.poll(); int v = e.u, w = e.v; if (uf.connected(v, w)) { continue; } uf.union(v, w); mst.offer(e); weight += e.weight; } } @Override public String toString() { return \u0026#34;\u0026#34; + mst; } public static void main(String[] args) { String[] vertices = {\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;}; int[][] edges = { {0, 1, 2}, {0, 3, 8}, {1, 0, 2}, {1, 2, 7}, {1, 3, 3}, {2, 1, 7}, {2, 3, 4}, {2, 4, 5}, {3, 0, 8}, {3, 1, 3}, {3, 2, 4}, {3, 4, 6}, {4, 2, 5}, {4, 3, 6} }; WeightedGraph\u0026lt;String\u0026gt; graph = new WeightedGraph\u0026lt;\u0026gt;(vertices, edges); graph.getMinimumSpanningTree().printTree(); System.out.println(graph.getMinimumSpanningTree().getTotalWeight()); KruskalUF k = new KruskalUF(graph); System.out.println(k.weight); System.out.println(k); } } 3.Dijkstra 单源最短路径 ，即最小总权重的路径 //要求图中不存在负权边 \t//每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止 \t//寻找点到点之间的最小总权重路线  public ShortestPathTree getShortestPath(int sourceVertex){//Algorithm Dijkstra  double[] cost = new double[size()]; Arrays.fill(cost , Double.POSITIVE_INFINITY); cost[sourceVertex] = 0 ; int[] parent = new int[size()]; parent[sourceVertex] = -1; List\u0026lt;Integer\u0026gt; T = new ArrayList\u0026lt;\u0026gt;(); while (T.size() \u0026lt; size()){ int u = -1; double curMinCost = Double.POSITIVE_INFINITY; for (int i = 0; i \u0026lt; size(); i++) { //开始搜寻加权图  if (!T.contains(i) \u0026amp;\u0026amp; cost[i] \u0026lt; curMinCost){ curMinCost = cost[i]; u = i; } } T.add(u); for (Edge e:neighbors.get(u)) { //与Prim的不同之处  if (!T.contains(e.v) \u0026amp;\u0026amp; cost[e.v] \u0026gt; cost[u] + ((MyWeightedEdge)e).weight){ cost[e.v] = cost[u] + ((MyWeightedEdge)e).weight; parent[e.v] = u; } } } return new ShortestPathTree(sourceVertex , parent , T , cost); } \rDijkstra\r\n如图所示，我们从1开始 , 然后就到2(min cost) ，更新cost和parent ；然后从2去到0 ， 更新 ， 从 0 去到 6 ；\n此时会变成 \rDijkstra\r\n3和5的权重相同，我们先去到3，此时更新cost，cost[4]变成了18 ， 因为我们还没有搜寻到{5, 4 , 4}\n\rDijkstra\r\n此时添加5 ， cost[4]才更新成最小总权重15\n\rDijkstra\r\n","date":"2021-06-02T23:58:08+08:00","image":"https://minezeratul.github.io/p/graph/wallhaven-o3ywdp_hu254556f4d7c6fac32ed9b7127f78f282_531223_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/graph/","title":"Graph Algorithms Part I"},{"content":"Leetcode 523 523. 连续的子数组和 给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：\n子数组大小 至少为2 ，且子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。\n如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。\npublic boolean checkSubarraySum(int[] nums, int k) { int n = nums.length; if (n \u0026lt; 2) {//大小至少为2  return false; } //利用了同余定理  //即 ( pre(j) - pre (i) ) % k == 0 则 pre(j) % k == pre(i) % k  //推导 =\u0026gt; pre (i) % k = (a0 + a1 + ... + ai) % k = (a0 % k + a1 % k + ... ai % k ) % k  //（该推导在简化前缀和的时候有用，说明当前前缀和 % k 不会影响后面的前缀和 % k ）  Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0, -1); int res = 0; for (int i = 0; i \u0026lt; n; i++) { res = (res + nums[i]) % k;//前缀和 取模  if (map.containsKey(res)) { int pre = map.get(res); if (i - pre \u0026gt;= 2) { //即子数组满足 len大小\u0026gt;=2 且 元素和为k的倍数  return true; } } else { map.put(res, i); } } return false; } ","date":"2021-06-02T09:46:48+08:00","image":"https://minezeratul.github.io/p/leetcode-523/wallhaven-l3zmwy_hudbd5d696bf0fe2f4290679ab32168e14_781731_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/leetcode-523/","title":"CheckSubArray"},{"content":"触宝周赛Week 243 不会做最后一题哈哈哈\n第一题5772. 检查某单词是否等于两单词之和\npublic boolean isSumEqual(String firstWord, String secondWord, String targetWord) { int ans = decode(firstWord) + decode(secondWord); return ans == decode(targetWord); } private int decode(String str) { int n = str.length(); int cnt = 0; //从个位开始计算  for (int i = n - 1, j = 1; i \u0026gt;= 0; i--, j = j * 10) { cnt += ((str.charAt(i) - \u0026#39;a\u0026#39;) * j); } return cnt; } 第二题 5773. 插入后的最大值\npublic String maxVal(String n, int x) { StringBuilder sb = new StringBuilder(); if (n.charAt(0) == \u0026#39;-\u0026#39;) {//若为负数，idx向后移一位  for (int i = 1; i \u0026lt; n.length(); i++) { if (n.charAt(i) - \u0026#39;0\u0026#39; \u0026gt; x) {//负数，大数往后  sb.append(n.substring(0, i)).append(x).append(n.substring(i)); return sb.toString(); } } } else { for (int i = 0; i \u0026lt; n.length(); i++) {//正数，大数往前  if (n.charAt(i) - \u0026#39;0\u0026#39; \u0026lt; x) { sb.append(n.substring(0, i)).append(x).append(n.substring(i)); return sb.toString(); } } } return n + x; } 第三题5774. 使用服务器处理任务\npublic int[] assignTasks(int[] servers, int[] tasks) { int n = servers.length , m = tasks.length; int[] ans = new int[m]; //双堆解决  //权重从小到大，index从小到大  PriorityQueue\u0026lt;ServerState\u0026gt; free = new PriorityQueue\u0026lt;\u0026gt;((a , b) -\u0026gt; { return a.weight == b.weight ? a.idx - b.idx : a.weight - b.weight; }); for (int i = 0; i \u0026lt; n; i++) { free.offer(new ServerState(i , servers[i] , 0)); } PriorityQueue\u0026lt;ServerState\u0026gt; busy = new PriorityQueue\u0026lt;\u0026gt;((a , b) -\u0026gt; { return a.ending == b.ending ? (a.weight == b.weight ? a.idx - b.idx : a.weight - b.weight) : a.ending - b.ending; }); for (int i = 0; i \u0026lt; m; i++) { ////检测busy中是否有完成时间小于\u0026lt;=当前时间的服务器，若有，则从busy中取出该服务器并加入free中  while (!busy.isEmpty() \u0026amp;\u0026amp; busy.peek().ending \u0026lt;= i){ free.offer(busy.poll()); } // 如果暂时没有可用的服务器，就用最先完成服务的那个，也就是busy的堆顶  // 更新服务结束时间，与下标j无关，因为已经不是从j时刻开始了  if (free.isEmpty()){ ServerState top = busy.poll(); top.ending += tasks[i]; ans[i] = top.idx; busy.offer(top); }else { ServerState cur = free.poll(); cur.ending = i + tasks[i]; ans[i] = cur.idx; busy.offer(cur); } } return ans; } class ServerState{//存储服务器的info  int idx; int weight; int ending; public ServerState(int idx , int weight , int ending){ this.idx = idx; this.weight = weight; this.ending = ending; } } ","date":"2021-05-30T16:09:40+08:00","image":"https://minezeratul.github.io/p/lcweek243/11_hu2bec06fe9b6da6a10901f7c47e4cf23e_1020898_120x120_fill_box_smart1_2.png","permalink":"https://minezeratul.github.io/p/lcweek243/","title":"Week-243 chubao"},{"content":"Leetcode 477 这是5.28的每日一题477. 汉明距离总和\n两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。\n给你一个整数数组 nums，请你计算并返回 nums 中任意两个数之间汉明距离的总和。\nInput:[4,14,2] Output:6\n题目要求数组的长度不超过 10^4。说明不能用 O^2 的时间复杂度的解法 , 所以461. 汉明距离的解法会超时\npublic int totalHammingDistance(int[] nums) { int ans = 0, n = nums.length; //10^9 \u0026lt; 2^30 ， 枚举到29位  for (int i = 0; i \u0026lt; 30; ++i) { int c = 0; for (int val : nums) { //来取出其第 i 位的值 , 得出不同位  c += (val \u0026gt;\u0026gt; i) \u0026amp; 1; } ans += c * (n - c); } return ans; } 461. 汉明距离的思路则为，利用异或同为0，异为1的特点，去算二进制位不同的数目\npublic int hammingDistance(int x, int y) { if (x == y) { return 0; } //剩下的均为不同位  int cnt = x ^ y, ans = 0; while (cnt != 0) { cnt \u0026amp;= cnt - 1; ans++; } return ans; } 还有一个汉明权重题191. 位1的个数\npublic int hammingWeight(int n) { int ret = 0; while (n != 0) { n \u0026amp;= n - 1; // n \u0026amp; (n - 1)消除二进制位最右边的一个1  ret++; } return ret; } ","date":"2021-05-29T08:58:15+08:00","image":"https://minezeratul.github.io/p/hamming/wallhaven-6q5p36_hufae14abfad3a71b129b2d8f1c44c25e5_153461_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/hamming/","title":"Hamming algs"},{"content":"Leetcode 1190 5.26的每日一题，需从内到外翻转字符串 ，我们可以遇到)就开始翻转内容\n可以用stack来存储每个(的index，找到第一个)的时候即为优先级最高的里面，开始第一次翻转char[]数组\nSample input:\u0026quot;(abcd)\u0026quot; output:\u0026quot;dcba\u0026quot;\npublic String reverseParentheses(String s) { StringBuilder sb = new StringBuilder();//用stringbuilder构建字符串  char[] chs = s.toCharArray(); int n = s.length(); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { if (chs[i] == \u0026#39;(\u0026#39;) {//记录index  stack.push(i); } if (chs[i] == \u0026#39;)\u0026#39;) {//匹配，开始  reverse(chs, stack.pop() + 1, i); } } for (int i = 0; i \u0026lt; n; i++) { if (chs[i] != \u0026#39;(\u0026#39; \u0026amp;\u0026amp; chs[i] != \u0026#39;)\u0026#39;) { sb.append(chs[i]); } } return sb.toString(); } private void reverse(char[] chs, int low, int high) { while (low \u0026lt; high) {//左右双指针往中间交换char  char temp = chs[low]; chs[low++] = chs[high]; chs[high--] = temp; } } \r1190\r\n","date":"2021-05-26T21:02:46+08:00","image":"https://minezeratul.github.io/p/stacktoreverse/wallhaven-39kpw3_hu9c930e440c445e06821af826ec0c1139_1083221_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/stacktoreverse/","title":"In Reverse , we finally meet in the sunset"},{"content":"如何理解quickSort? 最近在复习快排，便重新整理了一下，除了classic quickSort 还有变种quickSelectionSort(随机快排)，如215、1738，还有Dual-Pivot Partition、Three-Way Partition。 不同的partition复用，使其在面对不同情况下有不同的效果\n最常见的快排，最坏的情况是 1.已经/几乎有序 → 退化成冒泡排序\n2.pivot刚好是最大值/最小值\nHoare quickSort, 这个版本的算法在含有许多重复元素的情况下，可以避免其出现最坏情况的划分\npublic int partition(int[] a , int lo , int hi){ int p = a[lo]; int i = lo - 1 , j = hi + 1; while(true){ while(a[--j] \u0026gt; p); while(a[++i] \u0026lt; p); if(i \u0026lt; j) swap(a , i , j); else return j ; } } 这是改进后的，也是我们现在最常用的版本\npublic void quickSort(int[] arr){ quickSort(arr , 0 , arr.length - 1); } public void quickSort(int[]arr , int first , int last){ if (last \u0026gt; first){ int pivotIndex = partition(arr , first , last); quickSort(arr , first , pivotIndex - 1); quickSort(arr , pivotIndex + 1, last); } } public int partition(int[]arr , int first , int last){ int pivot = arr[first]; int low = first + 1; int high = last; while (high \u0026gt; low){ //Search left to right  while (high \u0026gt;= low \u0026amp;\u0026amp; arr[low] \u0026lt;= pivot){ low++; } //Search right to left  while (high \u0026gt;= low \u0026amp;\u0026amp; arr[high] \u0026gt; pivot){ high--; } if (high \u0026gt; low){ //swap the element in the array  swap(arr , low , high); } } while (high \u0026gt; first \u0026amp;\u0026amp; arr[high] \u0026gt;= pivot){ high--; } //swap the pivot  if (pivot \u0026gt; arr[high]){ swap(arr , first , high) return high; } else { return first; } } private void swap(int[] arr , int i , int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } 随机化 先洗牌后partition , 随机生成pivot , 然而并没有改变最坏情况下的运行时间，只是减少了出现最坏情况的可能，即无法保证每次pivot都是正中间的索引的。\n且quickSelectionSort不关心a[ lo\u0026hellip;p - 1] 和 a[p + 1 \u0026hellip; hi] 是否 有序 ，此方法一般应用于找Kth Element\nprivate int partition(int[] nums, int lo, int hi) { if (lo == hi) { return lo; } int pivot = nums[lo]; // j = hi + 1 因为 while 中会先执行--  int i = lo, j = hi + 1; while (true) { // 保证 nums[lo..i] 都小于 pivot  while (nums[++i] \u0026lt; pivot) { if (i == hi) { break; } } // 保证 nums[j..hi] 都大于 pivot  while (nums[--j] \u0026gt; pivot) { if (j == lo) { break; } } if (i \u0026gt;= j) { break; } swap(nums, i, j); } //交换pivot  swap(nums, j, lo); // 如果走到这里，一定有：  // nums[i] \u0026gt; pivot \u0026amp;\u0026amp; nums[j] \u0026lt; pivot  // 所以需要交换 nums[i] 和 nums[j]，  // 保证 nums[low..i] \u0026lt; pivot \u0026lt; nums[j..high]  return j; } private void shuffle(int[] nums) {//打乱数组  int n = nums.length; Random ran = new Random(); for (int i = 0; i \u0026lt; n; i++) { int r = i + ran.nextInt(n - i); swap(nums, i, r); } } //another ver. public int randomPartition(int[] a, int l, int r) { int i = random.nextInt(r - l + 1) + l; swap(a, i, r); return partition(a, l, r); } Lomuto划分 一个数组被分成三段 ，设最左为pivot , 一段是\u0026lt;a[pivot] , 一段\u0026gt;a[pivot] , 还有一段未处理的数据\n从左往右扫描数组，将第三段未处理的数据和p比较 , 其中 s指向 第一段末尾 ， i指向 第二段末尾\n若val \u0026gt;= a[p] 则 i++ / 若val \u0026lt;= a[p] , 则需要s++ ， 并和a[i]互换 ,然后 i++ ，继续指向尾端\n直到第三段为空，a[s] 与 a[pivot] 交换\n\rLomuto\r\npublic void quickSort(int[] a , int l , int r){ if(l \u0026lt; r){ int p = partition(a , l , r); quickSort(a , l , p - 1); quickSort(a , p + 1 , r); } } private int partition(int[] a ,int l, int r) { int p = a[l]; int s = l; for (int i = l + 1; i \u0026lt;= r; i++) { if (a[i] \u0026lt; p) { s = s + 1; int temp = a[s]; a[s] = a[i]; a[i] = temp; } } int temp = a[l]; a[l] = a[s]; a[s] = temp; return s; } Dual-Pivot Partition Arrays.sort()就是用该方法实现的\n 对于长度小于17的数组使用插入排序(常见优化步骤，传统快排也有应用)。 选择两个枢纽元p1,p2，一般选择起始元素a[left]和末尾元素a[right]（有其他选取方式）。 假设p1\u0026lt;p2，如果不是就交换。 将整个数组分成三部分，分别为 \u0026lt;p1的 , p1\u0026lt;X\u0026lt;p2 , \u0026gt;p2 的。 递归排序这三个部分。  \rDual-Pivot\r\n这样进行一次后递归的进行下一次双轴快排，一直到结束，但是在这个执行过程应该去如何处理分析呢？需要几个参数呢？\n 假设知道排序区间[start，end]。数组为arr， pivot1=arr[start],pivot2=arr[end] 还需要三个参数left，right和k。 l left初始为start，[start,left]区域即为小于等于pivot1小的区域(第一个等于)。 right与left对应，初始为end，[right,end]为大于等于pivot2的区域(最后一个等于)。 k初始为start+1，是一个从左往右遍历的指针，遍历的数值与pivot1，pivot2比较进行适当交换，当k\u0026gt;=right即可停止。  \rpre1\r\nk交换过程然后你可能会问k遍历时候究竟怎么去交换？left和right该如何处理呢？不急我带你慢慢分析，首先K是在left和right中间的，遍历k的位置和pivot1，pivot2进行比较：如果arr[k]\u0026lt;pivot1,那么先++left，然后swap(arr,k,left),**因为初始在start在这个过程不结束start先不动。**然后k++；继续进行\n\rpre2\r\n而如果arr[k]\u0026gt;pivot2.(区间自行安排即可) 有点区别的就是right可能连续的大于arr[k],比如9 3 3 9 7如果我们需要跳过7前面9到3才能正常交换，这和快排的交换思想一致，当然再具体的实现上就是right\u0026ndash;到一个合适比arr[k]小的位置。然后swap(arr,k,right)**切记此时k不能自加。**因为带交换的那个有可能比pivot1还小要和left交换。如果是介于两者之间，k++即可\n\rpre3\r\n最后则是在执行完这一趟即k=right之后，即开始需要将pivot1和pivot2的数值进行交换\nswap(arr, start, left); swap(arr, end, right); 然后三个区间根据编号递归执行排序函数即可。\n\rpre4\r\npublic void dualPivotQuickSort(int[] arr, int start, int end) { if(start \u0026gt; end){ return; } if(arr[start] \u0026gt; arr[end]) swap(arr, start, end); int pivot1 = arr[start] , pivot2 =a rr[end]; //取最左侧和最右侧作为pivot  //(start，left]:左侧小于等于pivot1 [right,end)大于pivot2  int left = start , right = end, k = left + 1; while (k \u0026lt; right) { //和左侧交换  if(arr[k] \u0026lt;= pivot1) { //需要交换  swap(arr, ++left, k++); } else if (arr[k]\u0026lt;=pivot2) {//在中间的情况  k++; } else { while (arr[right]\u0026gt;=pivot2) {//如果全部小于直接跳出外层循环  if(right--==k) break ; } if(k\u0026gt;=right)break ; swap(arr, k, right); } } swap(arr, start, left); swap(arr, end, right); //分段递归，继续排序  dualPivotQuickSort(arr, start, left-1); dualPivotQuickSort(arr, left+1, right-1); dualPivotQuickSort(arr, right+1, end); } private void swap(int arr[],int i,int j){ int team=arr[i]; arr[i]=arr[j]; arr[j]=team; } Three-Way Partition ， 三路快排 , Dijkstra / Bentley-McIlroy 以最左元素、最右元素、最中间元素为pivot ，在双轴快排的基础上，在分一个等于p的区段\nprivate void sort(Comparable[] arr, int l, int r){ // 对于小规模数组, 使用插入排序  if(r - l \u0026lt;= 15){ InsertionSort.sort(arr, l, r); return; } // 随机在arr[l...r]的范围中, 选择一个数值作为标定点pivot  swap(arr, l, (int)(Math.random()*(r-l+1)) + l ); Comparable v = arr[l]; int lt = l; // arr[l+1...lt] \u0026lt; v  int gt = r + 1; // arr[gt...r] \u0026gt; v  int i = l + 1; // arr[lt+1...i) == v  while(i \u0026lt; gt){ if(arr[i].compareTo(v) \u0026lt; 0){ swap( arr, i, lt + 1); i++; lt++; } else if(arr[i].compareTo(v) \u0026gt; 0){ swap(arr, i, gt - 1); gt--; } else{ // arr[i] == v  i++; } } swap(arr, l, lt); sort(arr, l, lt-1); sort(arr, gt, r); } private void swap(Object[] arr, int i, int j) { Object t = arr[i]; arr[i] = arr[j]; arr[j] = t; } Dijkstra / Bentley-McIlroy的源码 , 在无重复值的情况下，Bentley-McIlroy方法相较于双轴快排， 由于头尾只有少量的等值元素需要交换，所以额外的开销很小。\n// Dijkstra 3-way partitioning private static void sort(Comparable[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; int lt = lo, gt = hi; Comparable v = a[lo]; int i = lo+1; while (i \u0026lt;= gt) { int cmp = a[i].compareTo(v); if (cmp \u0026lt; 0) exch(a, lt++, i++); else if (cmp \u0026gt; 0) exch(a, i, gt--); else i++; } sort(a, lo, lt - 1); sort(a, gt + 1, hi); } // Bentley-McIlroy 3-way partitioning private static void sort(Comparable[] a, int lo, int hi) { int i = lo, j = hi+1; int p = lo, q = hi+1; Comparable v = a[lo]; while (true) { while (less(a[++i], v)) if (i == hi) break; while (less(v, a[--j])) if (j == lo) break; // pointers cross  if (i == j \u0026amp;\u0026amp; eq(a[i], v)) exch(a, ++p, i); if (i \u0026gt;= j) break; exch(a, i, j); if (eq(a[i], v)) exch(a, ++p, i); if (eq(a[j], v)) exch(a, --q, j); } i = j + 1; //多了交换的步骤  for (int k = lo; k \u0026lt;= p; k++) exch(a, k, j--); for (int k = hi; k \u0026gt;= q; k--) exch(a, k, i++); } ","date":"2021-05-22T21:08:13+08:00","image":"https://minezeratul.github.io/p/quicksort/wallhaven-y858yd_hu5438825b9b6d1014226d20d231e650c2_2128318_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/quicksort/","title":"Collections of quickSort"},{"content":"Leetcode 1738 这是Leetcode 5.19的题目 1738. 找出第 K 大的异或坐标值 ，是215. 数组中的第K个最大元素 的二维异或版本 215回顾\n第一种方法，用前缀异或 + PriorityQueue , Java是用最小堆实现pq\npublic int kthLargestValue(int[][] matrix, int k) { int m = mat.length , n = mat[0].length; int[][] pre = new int[m + 1][n + 1]; PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= m ; i++) { for (int j = 1; j \u0026lt;= n ; j++) { //二维数组的前缀异或  pre[i][j] = pre[i - 1][j] ^ pre[i][j - 1] ^ pre[i - 1][j - 1] ^ mat[i - 1][j - 1]; if (pq.size() \u0026lt; k){ pq.add(pre[i][j]); }else { if (pre[i][j] \u0026gt; pq.peek()){ //大于size直接去掉  //直到剩下K个值  //pq.peek()即是题目想要的第K大  pq.poll(); pq.add(pre[i][j]); } } } } return pq.peek(); } } 第二种方法，用前缀异或 + 排序\npublic int kthLargestValue(int[][] matrix, int k) { int m = matrix.length , n = matrix[0].length; int[][] prefix = new int[m + 1][n + 1]; List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); /** 二维数组的前缀异或 */ for (int i = 1; i \u0026lt;= m ; i++) { for (int j = 1; j \u0026lt;= n ; j++) { prefix[i][j] = prefix[i - 1][j] ^ prefix[i][j - 1] ^ prefix[i - 1][j - 1] ^ matrix[i - 1][j - 1]; list.add(prefix[i][j]); } } //这里用了Collections.sort(List , new Comparator(){  // @Override  //\tpublic int compare(Object o1 , Object o2) \t//});  //当o2 - o1 \u0026gt; 0 ,即把大的值放前面  //降序排列  Collections.sort(list, ((o1, o2) -\u0026gt; o2 - o1)); return list.get(k - 1); } ","date":"2021-05-22T19:47:51+08:00","image":"https://minezeratul.github.io/p/13rd-blog/wallhaven-3z3zdv_hu5438825b9b6d1014226d20d231e650c2_1578832_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/13rd-blog/","title":"K-Largest XOR Value"},{"content":"Leetcode K-Largest Val 215. 数组中的第K个最大元素 , 题目需要 在未排序的数组找到第 k 个最大的元素 ，而且不是第k个不同的元素\n先看简单方法，用Java的PriorityQueue来解答，需注意的是PriorityQueue是用小顶堆实现的\npublic int findKthLargest2(int[] nums, int k) { PriorityQueue\u0026lt;Integer\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(); //小顶堆去除元素  for (int num : nums) { pq.offer(num); if (pq.size() \u0026gt; k) { //因为我们只需要找到第K大的数,超过size直接去除堆顶元素就好  pq.poll(); } } return pq.peek(); } 亦或者和官方解答一样，用大顶堆实现也可以得出第K大的数\npublic int findKthLargest(int[] nums, int k) { int heapSize = nums.length; buildMaxHeap(nums, heapSize); for (int i = nums.length - 1; i \u0026gt;= nums.length - k + 1; --i) { swap(nums, 0, i); --heapSize; maxHeapify(nums, 0, heapSize); } return nums[0]; } public void buildMaxHeap(int[] a, int heapSize) { for (int i = heapSize / 2; i \u0026gt;= 0; i--) { maxHeapify(a, i, heapSize); } } public void maxHeapify(int[] a, int i, int heapSize) { int l = i * 2 + 1, r = i * 2 + 2, largest = i; if (l \u0026lt; heapSize \u0026amp;\u0026amp; a[l] \u0026gt; a[largest]) { largest = l; } if (r \u0026lt; heapSize \u0026amp;\u0026amp; a[r] \u0026gt; a[largest]) { largest = r; } if (largest != i) { swap(a, i, largest); maxHeapify(a, largest, heapSize); } } private void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } 第三种方法则是用quickSelectionSort 快速选择排序\npublic int findKthLargest(int[] nums, int k) { int low = 0, high = nums.length - 1; //因为无法保证每次pivot都是正中间的索引的  //所以我们需要对数组进行一次随机洗牌  shuffle(nums); k = nums.length - k; while (low \u0026lt;= high) { int p = partition(nums, low, high); if (p \u0026lt; k) { low = p + 1; } else if (p \u0026gt; k) { high = p - 1; } else { return nums[p]; } } return -1; } private int partition(int[] nums, int lo, int hi) { if (lo == hi) { return lo; } int pivot = nums[lo]; // j = hi + 1 因为 while 中会先执行--  int i = lo, j = hi + 1; while (true) { // 保证 nums[lo..i] 都小于 pivot  while (nums[++i] \u0026lt; pivot) { if (i == hi) { break; } } // 保证 nums[j..hi] 都大于 pivot  while (nums[--j] \u0026gt; pivot) { if (j == lo) { break; } } if (i \u0026gt;= j) { break; } //到了这一步的时候  //一定会有nums[i] \u0026gt; pivot \u0026amp;\u0026amp; nums[j] \u0026lt; pivot  //因此我们要交换num[i]和num[j]  //保证nums[low..i] \u0026lt; pivot \u0026lt; nums[j..high]  swap(nums, i, j); } //交换pivot  swap(nums, j, lo); // 现在 nums[low..j-1] \u0026lt; nums[j] \u0026lt; nums[j+1..high]  return j; } private void shuffle(int[] nums) {//随机打乱  int n = nums.length; Random ran = new Random(); for (int i = 0; i \u0026lt; n; i++) { int r = i + ran.nextInt(n - i); swap(nums, i, r); } } private void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } ","date":"2021-05-22T19:27:24+08:00","image":"https://minezeratul.github.io/p/12nd-blog/wallhaven-v9z9wl_hu5438825b9b6d1014226d20d231e650c2_1928554_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/12nd-blog/","title":"Largest Val in my mind xD"},{"content":"Database / SQL Code Student(Sid,Sname,Sage,Ssex) 学生表\nSid：学号；Sname：学生姓名；Sage：学生年龄；Ssex：学生性别\nCourse(Cid,Cname,Tid) 课程表\nCid,课程编号；Cname：课程名字；Tid：教师编号\nSC(Sid,Cid,score) 成绩表\nSid：学号；Cid,课程编号；score：成绩\nTeacher(Tid,Tname) 教师表\nTid：教师编号； Tname：教师名字\nCREATE TABLE Student ( Sid INT PRIMARY KEY NOT NULL, Sname nvarchar(32) NOT NULL, Sage DATETIME NOT NULL, Ssex nvarchar(8) NOT NULL ) CREATE TABLE Course ( Cid INT PRIMARY KEY, Cname nvarchar(32) NOT NULL, Tid INT NOT NULL ) CREATE TABLE SC ( Sid INT NOT NULL, Cid INT NOT NULL, score INT NOT NULL, PRIMARY KEY(Sid , Cid) ) CREATE TABLE Teacher ( Tid INT PRIMARY KEY NOT NULL, Tname nvarchar(16) NOT NULL ) 问题： 1、查询“001”课程比“002”课程成绩高的所有学生的学号； SELECT Sid FROM SC AS a , SC AS b where a.Sid = b.Sid And a.Cid = \u0026#34;001\u0026#34; And b.Cid = \u0026#34;002\u0026#34; And a.score \u0026gt; b.score; 2、查询平均成绩大于60分的同学的学号和平均成绩； SELECT Sid , AVG(Score) FROM SC GROUP BY Sid HAVING AVG(Score) \u0026gt; 60; 3、查询所有同学的学号、姓名、选课数、总成绩； SELECT Sid , Sname , COUNT(SC.Cid) as ClassNum , SUM(SC.Score) As Score FROM Student LEFT JOIN SC ON Student.Sid = SC.Sid GROUP BY Sid , Sname; 4、查询姓“李”的老师的个数； SELECT COUNT(DISTINCT(Tname)) From Teacher WHERE Tname LIKE \u0026#39;李%\u0026#39;; 5、查询没学过“叶平”老师课的同学的学号、姓名； SELECT Sid , Sname FROM Student WHERE Sid NOT IN( SELECT DISTINCT Sid FROM SC , Course , Teacher WHERE SC.Cid = Course.Cid AND Teacher.Tid = Course.Tid AND Teacher.Tname = \u0026#39;叶平\u0026#39; ) ); 6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名； SELECT Sid , Student.Sname FROM Student , SC WHERE Sid = SC.Sid AND EXISTS( Select * from SC as SC_2 where SC_2.SID = SC.SID and SC_2.Cid =\u0026#39;002\u0026#39; ); 7、查询学过“叶平”老师所教的所有课的同学的学号、姓名； SELECT Sid , Sname FROM Student WHERE Sid IN( SELECT DISTINCT Sid FROM SC WHERE cid IN ( SELECT Cid FROM course WHERE Tid = ( SELECT Tid FROM Teacher WHERE Tname = \u0026#34;叶平\u0026#34; ) ) ); 8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名； SELECT DISTINCT Sid , Sname FROM Student , SC AS a , SC AS b WHERE a.Sid = b.Sid AND a.Cid = \u0026#39;001\u0026#39; AND b.Cid = \u0026#39;002\u0026#39; AND a.Score \u0026gt; b.Score 9、查询所有课程成绩小于60分的同学的学号、姓名； SELECT Sid , Student.Sname FROM Student , SC WHERE Sid = SC.Sid AND Sc.Score \u0026lt; 60; 13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩； UPDATE SC SET Score = (SELECT AVG(a.Score) FROM SC AS a WHERE a.Cid = SC.Cid) FROM Course , Teacher WHERE Teacher.Tid = Course.Tid AND Course.Cid = SC.Cid AND Teacher.Tname = \u0026#39;叶平\u0026#39;; 14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名； SELECT Sid , Student.Sname FROM Student , SC WHERE Student.Sid = SC.Sid AND Cid IN (SELECT Cid FROM SC WHERE Sid =\u0026#39;1002\u0026#39;) GROUP BY Sid HAVING COUNT(*) = (SELECT COUNT(*) FROM SC WHERE Sid =\u0026#39;1002\u0026#39;); 15、删除学习“叶平”老师课的SC表记录； DELETE SC FROM Course , Teacher WHERE Course.Cid = SC.Cid AND Teacher.Tid = Course.Tid AND Teacher.Tname = \u0026#39;叶平\u0026#39;; 17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示： 学生ID,,数据库,企业管理,英语,有效课程数,有效平均分 SELECT Sid as StuID , (SELECT score FROM SC WHERE SC.Sid = t.id AND Cname = \u0026#39;Database\u0026#39;) AS DataBaseSYS , (SELECT score FROM SC WHERE SC.Sid = t.Sid AND Cname =\u0026#39;Management\u0026#39;) AS Management , (SELECT score FROM SC WHERE SC.Sid = t.Sid AND Cname =\u0026#39;English \u0026#39;) AS English , COUNT(*) AS 有效课程数, AVG(t.score) AS 平均成绩 FROM SC AS t GROUP BY Sid ORDER BY AVG(t.score) 18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分 SELECT a.Cid AS CourseID , a.Score AS MaxScore , b.Score AS MinScore FROM SC AS a , SC AS b WHERE a.Cid = b.Cid AND MaxScore = ( SELECT MAX(c.Score) FROM SC AS c , Student WHERE c.Sid = Student.Sid AND a.Cid = c.Cid GROUP BY c.Cid ) AND MinScore = ( SELECT MIN(d.Score) FROM SC AS d WHERE b.Cid = d.Cid GROUP BY d.Cid ); 19、按各科平均成绩从低到高和及格率的百分数从高到低顺序 SELECT SC.Cid , MAX(Course.Cname) , AVG(SC.SCORE) AS AVERAGE , 100 * SUM(CASE WHEN SC.score \u0026gt;= 60 THEN 1 ELSE 0 END)/COUNT(*) AS PassRate FROM SC , Course WHERE SC.Cid = Course.Cid, GROUP BY Cid , ORDER BY AVERAGE ASC, PassRate DESC; 21、查询不同老师所教不同课程平均分从高到低显示 SELECT MAX(Teacher.Tid) , MAX(Teacher.Tname) ,Course.cid , MAX(Course.Cname) ,AVG(SC.Score) AS AVERAGE FROM SC , Teacher , Course WHERE Teacher.Tid = Course.Tid AND Course.Cid = SC.Cid GROUP BY Course.Cid ORDER BY AVG(Score) DESC; 23、统计列印各科成绩,各分数段人数:课程ID,课程名称,[100-85],[85-70],[70-60],[ \u0026lt;60] SELECT Cid , Cname , SUM(CASE WHEN SC.score \u0026lt; 60 THEN 1 ELSE 0 END) AS LowerThan60 SUM(CASE WHEN SC.score BETWEEN 60 AND 70 THEN 1 ELSE 0 END) AS Between60And70 SUM(CASE WHEN SC.score BETWEEN 70 AND 85 THEN 1 ELSE 0 END) AS Between70And85 SUM(CASE WHEN SC.score BETWEEN 85 AND 100 THEN 1 ELSE 0 END) AS Between85And100 FROM Course , SC WHERE SC.Cid = Course.Cid GROUP BY SC.Cid , Cname; 24、查询学生平均成绩及其名次 SELECT 1 + (SELECT COUNT(DISTINCT AVERAGE) FROM ( SELECT Sid , AVG(SCORE) AS AVERAGE FROM SC GROUP BY Sid ) AS T1 WHERE AVERAGE \u0026gt; T2.AVERAGE) AS Rank , Sid AS StuID , FROM (SELECT Sid, AVG(SCORE) AS AVERAGE FROM SC GROUP BY Sid ) AS T2 ORDER BY AVERAGE DESC; 25、查询各科成绩前三名的记录:(不考虑成绩并列情况) SELECT Sid , Cid , Score FROM SC a WHERE SCORE IN (SELECT TOP 3 Score From SC WHERE a.Cid = SC.Cid ORDER BY Score DESC ) ORDER BY Cid; 26、查询每门课程被选修的学生数 SELECT Cid ,COUNT(Sid) FROM SC GROUP BY Cid; 27、查询出只选修了一门课程的全部学生的学号和姓名 SELECT Sid , Sname , COUNT(Cid) AS numOfClass FROM Student , SC WHERE Student.Sid = SC.Sid GROUP BY Sid , Sname HAVING COUNT(Cid) = 1; 28、查询男生、女生人数 SELECT COUNT(a.Ssex) AS Male FROM Student GROUP BY Ssex HAVING Ssex = \u0026#39;男\u0026#39;; SELECT COUNT(b.Ssex) AS Female FROM Student GROUP BY Ssex HAVING Ssex = \u0026#39;女\u0026#39;; 29、查询姓“张”的学生名单 SELECT Sname FROM Student WHERE Sname like \u0026#39;张%\u0026#39;; 30、查询同名同性学生名单，并统计同名人数 SELECT Sname , Ssex , COUNT(*) FROM Student GROUP BY Sname HAVING COUNT(*) \u0026gt; 1; 31、1981年出生的学生名单(注：Student表中Sage列的类型是datetime) SELECT Sname , Sid , CONVERT(char (11),DATEPART(year,Sage) AS AGE FROM Student WHERE AGE = \u0026#39;1981\u0026#39;; 32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列 SELECT Cid ,AVG(Score) FROM SC GROUP BY Cid ORDER BY AVG(Score), Cid DESC ; 33、查询平均成绩大于85的所有学生的学号、姓名和平均成绩 SELECT Sid , Sname , AVG(Score) AS AVERAGE FROM Student , SC WHERE Student.Sid = SC.Sid GROUP BY SC.Sid , Sname HAVING AVG(Score) \u0026gt; 85; 34、查询课程名称为“数据库”，且分数低于60的学生姓名和分数 SELECT Sname , Score FROM Student , SC , Course WHERE Student.Sid = SC.Sid AND Course.Cid = SC.Cid AND Course.Cname = \u0026#39;数据库\u0026#39; AND Score \u0026lt; 60; 35、查询所有学生的选课情况； SELECT Sid , Sname , Cid , Cname FROM Student , Course , SC WHERE Student.Sid = SC.Sid AND Course.Cid = SC.Cid; 36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数； SELECT DISTINCT Student.Sid , Student.Sname , SC.Cid , SC.Score FROM Student , SC WHERE SC.score \u0026gt;= 70 AND SC.Sid = Student.Sid; 37、查询不及格的课程，并按课程号从大到小排列 SELECT Cid FROM SC WHERE Score \u0026lt; 60 ORDER BY Cid; 38、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名； SELECT Sid , Sname FROM Student , SC WHERE Student.Sid = SC.Sid AND SC.Cid = \u0026#39;003\u0026#39; AND SC.Score \u0026gt; 80; 40、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩 SELECT Student.Sname , Score FROM Student , SC , Course WHERE Student.Sid = SC.Sid AND Course.Cid = SC.Cid AND Course.Tname = \u0026#39;叶平\u0026#39; AND Score = (SELECT Max(Score) FROM SC WHERE Cid = SC.Cid ) 41、查询各个课程及相应的选修人数 SELECT COUNT(*) FROM SC GROUP BY Cid; 43、查询每门功成绩最好的前两名 SELECT Sid , Cid , Score FROM SC AS a WHERE Score IN ( SELECT TOP 2 Score FROM SC WHERE a.Cid = SC.Cid ORDER BY Score DESC ) ORDER BY a.Cid; 44、统计每门课程的学生选修人数（超过10人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，查询结果按人数降序排列，若人数相同，按课程号升序排列 SELECT Cid as ClassId, COUNT(*) AS counts FROM SC GROUP BY Cid HAVING COUNT(*) \u0026gt; 10 ORDER BY COUNT(*) DESC , Cid ASC; 45、检索至少选修两门课程的学生学号 SELECT Sid FROM SC GROUP BY Sid HAVING COUNT(*) \u0026gt;= 2; 46、查询全部学生都选修的课程的课程号和课程名 SELECT Cid , Cname FROM Course WHERE Cid in (SELECT Cid FROM SC GROUP BY Cid ); 47、查询没学过“叶平”老师讲授的任一门课程的学生姓名 SELECT Sname FROM Student WHERE Sid NOT IN (SELECT Sid FROM SC , Course , Teacher WHERE Course.Cid = SC.Cid AND Teacher.Tid = Course.Tid AND Teacher.Tname = \u0026#39;叶平\u0026#39;; ); 48、查询两门以上不及格课程的同学的学号及其平均成绩 SELECT Sid , AVG(isnull(Score , 0)) FROM SC WHERE Sid in (SELECT Sid FROM SC WHERE Score \u0026lt; 60 GROUP BY Sid HAVING count(*) \u0026gt; 2 ) GROUP BY Sid; 49、检索“004”课程分数小于60，按分数降序排列的同学学号 SELECT Sid FROM SC WHERE Score \u0026lt; 60 AND Cid = \u0026#34;004\u0026#34; ORDER BY Score DESC; 50、删除“002”同学的“001”课程的成绩 DELETE From SC WHERE Sid = \u0026#34;002\u0026#34; AND Cid = \u0026#39;001\u0026#39; ","date":"2021-05-20T14:49:56+08:00","image":"https://minezeratul.github.io/p/mysql-learning/head_hu7ce4f066287f8312f26249d9427cec69_784954_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/mysql-learning/","title":"SQLPratice"},{"content":"Find the Kth-frequency word 这是5.19 的 692. 前K个高频单词\n用哈希表 + 排序， HashMap记录次数 , 然后从大到小排列 public static List\u0026lt;String\u0026gt; topKFrequent(String[] words, int k) { Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); for (String word : words) { map.put(word, map.getOrDefault(word, 0) + 1); } for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { ans.add(entry.getKey()); } Collections.sort(ans, new Comparator\u0026lt;String\u0026gt;() { //compare\u0026gt;0则大在前 \u0026lt;0则大在后  //compareTo 比较两个str  @Override public int compare(String o1, String o2) { return map.get(o1).equals(map.get(o2)) ? o1.compareTo(o2) : map.get(o2) - map.get(o1); } }); return ans.subList(0, k); } 用 哈希表 + java pq , 最小堆去除 public static List\u0026lt;String\u0026gt; topKFrequent(String[] words, int k) { List\u0026lt;String\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String word : words) { map.put(word, map.getOrDefault(word, 0) + 1); } PriorityQueue\u0026lt;Map.Entry\u0026lt;String, Integer\u0026gt;\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;(new Comparator\u0026lt;Map.Entry\u0026lt;String, Integer\u0026gt;\u0026gt;() {//同样利用Comparator 进行比较  @Override public int compare(Map.Entry\u0026lt;String, Integer\u0026gt; o1, Map.Entry\u0026lt;String, Integer\u0026gt; o2) { return o1.getValue().equals(o2.getValue()) ? o2.getKey().compareTo(o1.getKey()) : o1.getValue() - o2.getValue(); } }); for (Map.Entry\u0026lt;String, Integer\u0026gt; entry : map.entrySet()) { pq.offer(entry); if (pq.size() \u0026gt; k) { pq.poll(); } } while (!pq.isEmpty()) { ans.add(pq.poll().getKey()); } Collections.reverse(ans);//逆序  return ans; } ","date":"2021-05-19T10:32:16+08:00","image":"https://minezeratul.github.io/p/kth-word/wallhaven-kww621_hu372b036221b09c8e585f89078ca6399d_640712_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/kth-word/","title":"You hava my word now"},{"content":"Leetcode 1442 5.18的每日一题1442. 形成两个异或相等数组的三元组数目\na = arr[i] ^ arr[i + 1] ^ \u0026hellip; ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ \u0026hellip; ^ arr[k\n利用了x^y = 0 ，可知两个数必相等。计算每个数的异或 ， 若出现0 ， 则说明该区间有能够令 a == b 成立的三元组 (i, j , k) 的数目\n其实 i ^ k = 0 , i \u0026lt; j \u0026lt;= k , j在区间范围内，异或结果都等于0\nTalk is cheap , show u the code XDDDD\npublic int countTriplets(int[] arr) { int n = arr.length; int ans = 0; //int[] s = new int[n + 1];  //for (int i = 0; i \u0026lt; n; ++i) {  // s[i + 1] = s[i] ^ arr[i];  //} 官解用了[前缀异或]的方法来解答  for (int i = 0; i \u0026lt; n; i++) { int sum = 0; for (int k = i ; k \u0026lt; n ; k++){ sum ^= arr[k]; if (sum == 0)//if(s[i] == s[k + 1]) 即有三元区间 使得结果=0  ans += (k - i); } } return ans; } 时间复杂度：O(n)\n空间复杂度：O(n)\n","date":"2021-05-18T19:32:07+08:00","image":"https://minezeratul.github.io/p/eleventh-blog/wallhaven-wq1o8p_hufcd2f25bc6dea744efafee36c63d9ed8_1117287_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/eleventh-blog/","title":"又又又是XOR"},{"content":"Leetcode 993 5.17的每日一题993. 二叉树的堂兄弟节点\n同深度 ， 不同父节点 就可判断\n直接dfs查找，若不存在，返回null\n不在第n层就继续往下走\npublic class isCousins993 { TreeNode parX; TreeNode parY; int deepX; int deepY; public boolean isCousins(TreeNode root, int x, int y) { dfs(root, null, 0, x, y); return parX != parY \u0026amp;\u0026amp; deepX == deepY; } private void dfs(TreeNode root, TreeNode par, int deep, int x, int y) { if (root == null) return; if (root.val == x) { deepX = deep; parX = par; } else if (root.val == y) { deepY = deep; parY = par; } else { dfs(root.left, root, deep + 1, x, y); dfs(root.right, root, deep + 1, x, y); } } } ","date":"2021-05-17T10:43:19+08:00","image":"https://minezeratul.github.io/p/tenth-blog/wallhaven-rdg3dm_hucaf993a63a550e009a6d2190b51b5980_274278_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/tenth-blog/","title":"Are u my cousin?"},{"content":"Leetcode 421 FineMaxXOR 5.16的题目 421. 数组中两个数的最大异或值\n用到了 208. 实现 Trie (前缀树) algs4的chapter5.2\npublic class Trie { private Trie[] children; private boolean isEnd; public Trie() { children = new Trie[26];//字母表映射  isEnd = false; } //插入字符串 \t//我们从字典树的根开始,插入字符串。对于当前字符对应的子节点,有两种情况 \t//子节点存在。沿着指针移动到子节点,继续处理下一个字符。 \t//子节点不存在。创建一个新的子节点,记录在children数组的对应位置上,  //然后沿着指针移动到子节点,继续搜索下一个字符。  public void insert(String word) { Trie node = this;//root  for (int i = 0; i \u0026lt; word.length(); i++) { char ch = word.charAt(i); int index = ch - \u0026#39;a\u0026#39;; if (node.children[index] == null) node.children[index] = new Trie(); node = node.children[index]; } node.isEnd = true; } public boolean search(String word) { Trie node = searchPrefix(word); return node != null \u0026amp;\u0026amp; node.isEnd; } public boolean startsWith(String prefix) { return searchPrefix(prefix) != null; } //查找前缀 \t//我们从字典树的根开始,查找前缀。对于当前字符对应的子节点,有两种情况 \t//子节点存在:沿着指针移动到子节点,继续搜索下一个字符,直到isEnd = true \t//子节点不存在:说明字典树中不包含该前缀,返回null。  private Trie searchPrefix(String prefix) { Trie node = this; for (int i = 0; i \u0026lt; prefix.length(); i++) { char ch = prefix.charAt(i); int index = ch - \u0026#39;a\u0026#39;; if (node.children[index] == null) return null; node = node.children[index]; } return node; } } \rTrie tree\r\n421则是用了Trie的方法来做\nclass Solution { // 字典树的根节点  Trie root = new Trie(); // 最高位的二进制位编号为 30  static final int HIGH_BIT = 30; public int findMaximumXOR(int[] nums) { int n = nums.length; int x = 0; for (int i = 1; i \u0026lt; n; ++i) { // 将 nums[i-1] 放入字典树，此时 nums[0 .. i-1] 都在字典树中  add(nums[i - 1]); // 将 nums[i] 看作 a_i，找出最大的 x 更新答案  x = Math.max(x, check(nums[i])); } return x; } public void add(int num) { Trie cur = root; for (int k = HIGH_BIT; k \u0026gt;= 0; --k) { int bit = (num \u0026gt;\u0026gt; k) \u0026amp; 1; if (bit == 0) { if (cur.left == null) { cur.left = new Trie(); } cur = cur.left; } else { if (cur.right == null) { cur.right = new Trie(); } cur = cur.right; } } } //尽可能找异位 , 0 ⊕ 1 = 1 , 使得值为最大  public int check(int num) { Trie cur = root; int x = 0; for (int k = HIGH_BIT; k \u0026gt;= 0; --k) { int bit = (num \u0026gt;\u0026gt; k) \u0026amp; 1; if (bit == 0) { // a_i 的第 k 个二进制位为 0，应当往表示 1 的子节点 right 走  if (cur.right != null) { cur = cur.right; x = x * 2 + 1; } else { cur = cur.left; x = x * 2; } } else { // a_i 的第 k 个二进制位为 1，应当往表示 0 的子节点 left 走  if (cur.left != null) { cur = cur.left; x = x * 2 + 1; } else { cur = cur.right; x = x * 2; } } } return x; } } } class Trie { Trie left = null;//0  Trie right = null;//1 } ","date":"2021-05-16T23:21:51+08:00","image":"https://minezeratul.github.io/p/ninth-blog/wallhaven-z8p1jy_hu38044c2a6d833b8cc715b17eaec2c4bb_307896_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/ninth-blog/","title":"Trie \u0026 XOR"},{"content":"Leetcode 740 5.5的题目740. 删除并获得点数 和 198. 打家劫舍 有点类似 , 需要在一些地方做出调整\n为了做740，先去当了一遍小偷XDDD\n打家劫舍，经典dp问题，偷还得隔间偷,甚至开了透视知道哪里最多钱（笑\n一间的时候肯定只能偷那个，两间的时候就需要Math.max比较\nn间的时候则需要 when i \u0026gt; 2 , Math.max(dp[i - 2] + num[i] , dp[i - 1])来比较金额大小\npublic int rob(int[] nums) { int n = nums.length; if (n == 0 || nums == null) return 0; else if (n == 1) return nums[0]; /** int[] dp = new int[n]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i \u0026lt; n; i++) { dp[i] = Math.max(dp[i - 2] + nums[i] , dp[i -1]); } return dp[n - 1]; */ //最大金额只与前两间房子的最大值相关  //用滚动数组优化  int first = nums[0], second = Math.max(nums[0], nums[1]); for (int i = 2; i \u0026lt; n; i++) { int temp = second; second = Math.max(first + nums[i], second); first = temp; } return second; } 时间复杂度：O(n) ， 需要对整个num数组遍历一次\n空间复杂度：O(1)，不需要存储每次计算结果\n 740的话，需要先找出最大值max , 因为需要用一个all数组来记录相同元素之和 , 防止out of bound\n/** * 根据题意,在选择了元素x后,该元素以及所有等于x-1或x+1的元素会从数组中删去。 * 若还有多个值为x的元素,由于所有等于x-1或x+1的元素已经被删除,我们可以直接删除并获得其点数。 * 因此若选择了x,所有等于x的元素也应同被选择,以尽可能多地获得点数。 */ public int deleteAndEarn(int[] nums){ int n = nums.length; if (n == 0 || nums == null) return 0; else if (n == 1) return nums[0]; int max = 0; for (int maxVal:nums) { max = Math.max(maxVal , max);//防止out of bounds  } int[] all = new int[max + 1]; for (int val : nums) all[val] += val; return rob(all); } private int rob(int[] nums){ int n = nums.length; int first = nums[0] , second = Math.max(nums[0] , nums[1]); for (int i = 2; i \u0026lt; n; i++) { int temp = second; second = Math.max(first + nums[i], second); first = temp; } return second; } 时间复杂度O(N+M) , 其中N是数组nums的长度, M是num中元素的最大值。\n空间复杂度:O(M)\n","date":"2021-05-16T00:47:24+08:00","image":"https://minezeratul.github.io/p/eighth-blog/wallhaven-3zqdjv_hua3d208be2a18f6c69f0bc48a70d7f9db_2862984_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/eighth-blog/","title":"Rob me if u can"},{"content":"Leetcode 1482 这是5.9号的题目 1482. 制作 m 束花所需的最少天数\n二分的应用场景不一定有序，只要具备排他性、两段性，就可以二分\n寻找最优临界值的题目，往往可以借助二分搜索\n/** * @param bloomDay 什么时候开花 * @param m m束 * @param k k朵花做成一束 * @return */ public static int minDays(int[] bloomDay, int m, int k) { int n = bloomDay.length; if (n \u0026lt; m * k)//不够花束  return -1; int low = Integer.MAX_VALUE, high = 0; for (int i = 0; i \u0026lt; n; i++) { low = Math.min(low, bloomDay[i]);//找到最小值作为low  high = Math.max(high, bloomDay[i]);//找到最大值作为high  } while (low \u0026lt; high) {//不断靠近目标值,当low = high时，此时即为最少天数  int days = (high - low) / 2 + low; if (canMake(bloomDay, days, m, k)) { high = days; } else { low = days + 1; } } return low; } //辅助函数，找到临界点  public static boolean canMake(int[] bloomDay, int days, int m, int k) { //在确保可以制作出指定数量的花束的情况下，所需的最少天数一定会大于min，小于max  //days很小的时候，总是返回false，不够做够花束，而days很大的时候，则总是返回true  int bouquets = 0; int flowers = 0; int length = bloomDay.length; for (int i = 0; i \u0026lt; length \u0026amp;\u0026amp; bouquets \u0026lt; m; i++) { if (bloomDay[i] \u0026lt;= days) { flowers++; if (flowers == k) { bouquets++; flowers = 0; } } else { flowers = 0; } } return bouquets \u0026gt;= m; }\t","date":"2021-05-15T20:47:24+08:00","image":"https://minezeratul.github.io/p/seventh-blog/wallhaven-v9qy9l_huf424ae543613049e9d1957ffc0ce99c4_1243068_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/seventh-blog/","title":"minDays 1482"},{"content":"Leetcode 12 and Leetcode 13 5.14和5.15的每日一题 ，貌似没有什么可写的，可能就需要用StringBuilder来构建string\n12. 整数转罗马数字 class Solution { public String intToRoman(int num) { StringBuilder sb = new StringBuilder(); int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; for (int i = 0; i \u0026lt; values.length; i++) { int val = values[i]; while (num \u0026gt;= val){ num -= val; sb.append(getStr(val)); if (num == 0) break; } } return sb.toString(); } private String getStr(int num){ switch (num){ case 1000: return \u0026#34;M\u0026#34;; case 900: return \u0026#34;CM\u0026#34;; case 500: return \u0026#34;D\u0026#34;; case 400: return \u0026#34;CD\u0026#34;; case 100: return \u0026#34;C\u0026#34;; case 90: return \u0026#34;XC\u0026#34;; case 50: return \u0026#34;L\u0026#34;; case 40: return \u0026#34;XL\u0026#34;; case 10: return \u0026#34;X\u0026#34;; case 9: return \u0026#34;IX\u0026#34;; case 5: return \u0026#34;V\u0026#34;; case 4: return \u0026#34;IV\u0026#34;; case 1: return \u0026#34;I\u0026#34;; } return null; } } 13. 罗马数字转整数 public int romanToInt(String s) { int count = 0; int size = s.length(); for (int i = 0; i \u0026lt; size; i++) { if (i + 1 == size) count += getVal(s.charAt(i)); else { if (getVal(s.charAt(i + 1)) \u0026lt;= getVal(s.charAt(i))) count += getVal(s.charAt(i)); else { count += getVal(s.charAt(i + 1)) - getVal(s.charAt(i)); i++; } } } return count; } public int getVal(char ch) { switch (ch) { case \u0026#39;I\u0026#39;: return 1; case \u0026#39;V\u0026#39;: return 5; case \u0026#39;X\u0026#39;: return 10; case \u0026#39;L\u0026#39;: return 50; case \u0026#39;C\u0026#39;: return 100; case \u0026#39;D\u0026#39;: return 500; case \u0026#39;M\u0026#39;: return 1000; default: return 0; } } ","date":"2021-05-15T00:00:00+08:00","image":"https://minezeratul.github.io/p/6th-blog/wallhaven-rdqvpq_hu4a0c1228b7c9baee4eb7cca01158b3ad_537850_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/6th-blog/","title":"intToRoman and RomanToInt"},{"content":"Leetcode 307 这是今天做的一个题 307. 区域和检索 - 数组可修改\n和 303. 区域和检索 - 数组不可变 不同的是 数组可修改\n上一个dalao的分析 , 放弃996了\n/** * 数组不变，求区间和：「前缀和」、「树状数组」、「线段树」 * * 多次修改某个数，求区间和：「树状数组」、「线段树」 * * 多次整体修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间的数据范围） * * 多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间的数据范围） * */ 学了个树状数组方法。\nclass NumArray { int[] tree; int lowBits(int x){ return x \u0026amp; -x;//保留二进制下最后出现的1的位置，其余位置置0  } //当一个偶数与它的负值向与时，结果是能被这个偶数整除的最大的2的n次幂 , 比如10返回2  //当一个奇数与它的负值向与时结果一定是1  // 查询前缀和的方法  int query(int x){ int ans = 0; for (int i = x; i \u0026gt; 0 ; i -= lowBits(i)) { ans += tree[i]; } return ans; } // 在树状数组 x 位置中增加值 u  void add(int x ,int u){ for (int i = x; i \u0026lt;= n ; i += lowBits(i)) { tree[i] += u; } } int[] nums; int n; // 初始化「树状数组」  public NumArray(int[] nums) { this.nums = nums; n = nums.length; tree = new int[n + 1]; for (int i = 0; i \u0026lt; n; i++) { add(i + 1, nums[i]); } } // 原有的值是 nums[i]，要使得修改为 val，需要增加 val - nums[i]  public void update(int index, int val) { add(index + 1 , val - nums[index]); nums[index] = val; } public int sumRange(int left, int right) { return query(right + 1) - query(left); } } ","date":"2021-05-13T00:00:00+08:00","image":"https://minezeratul.github.io/p/5th-blog/wallhaven-nkd6x6_hu91ef828cf299bfb62d37d6673a920b75_286363_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/5th-blog/","title":"NumArray307"},{"content":"Leetcode 1310 今天又是爆肝的一天 , 感觉这个月应该 是异或月了，全是异或题（痛哭）\n今天的每日一题是1310. 子数组异或查询\nqueries数组提供的是查询的范围\n然后返回一个包含所有查询结果的数组\n我们可以用类似 prefix sum 前缀和\n采取 prefix XOR前缀异或 来完成该题\n对于每个查询都要计算，因此我们应该优化每个查询的计算时间\nqueries(L , R)\n= array[L] ⊕ \u0026hellip;. ⊕ array[R] , 又 x ⊕ x = 0\n= ( array[0] ⊕ \u0026hellip;. ⊕ array[L - 1] ) ⊕ ( array[0] ⊕ \u0026hellip;. ⊕ array[L - 1] ) ⊕ ( array[L] ⊕ \u0026hellip;. ⊕ array[R] )\n= ( array[0] ⊕ \u0026hellip;. ⊕ array[L - 1] ) ⊕ ( array[0] ⊕ \u0026hellip;. ⊕ array[R] )\n= XORS[L] ⊕ XORS[R + 1]\nXORS为存储 前缀异或 的数组 , 当L = 0时，XORS[0] = 0 ，以上等式仍然成立\n数组不变，求区间 , 都可以用prefix来解决\n public static int[] xorQueries(int[] arr, int[][] queries) { int n = arr.length; int[] pre = new int[n + 1]; //计算每个位置的前缀和 pre[i] 表示前i项的异或和  for (int i = 1; i \u0026lt;= n; i++) { pre[i] = pre[i - 1] ^ arr[i - 1]; } int[] ans = new int[queries.length]; int i = 0; /** * for (int i = 0; i \u0026lt; m; i++) { * ans[i] = xors[queries[i][0]] ^ xors[queries[i][1] + 1]; * } */ for (int[] query : queries) { //前面多异或的部分，再重复异或一次就可以抵消了  //假设 求 [1, 2]，那么对于 [0, 2] 来说就是多异或了 [0, 0] 这个结果  //根据 两个相同值异或结果为 0，那么我们可以再异或一次 [0, 0] 就将 [0, 0] 给抵消掉了  //pre[query[0]]代表了[0, 0]异或 pre[query[1] + 1]代表了[0, 2]异或 其中[0, 0]异或两次  //最后相当于[1, 2]异或  ans[i++] = pre[query[0]] ^ pre[query[1] + 1]; } return ans; } 时间复杂度：O(n+m) , n , m 分别为array , queries数组的长度\n空间复杂度：O(n)\n类似题目有307. 区域和检索 - 数组可修改\n","date":"2021-05-12T18:40:29+08:00","image":"https://minezeratul.github.io/p/4th-blog/wallhaven-281d5y_hue3cb4f8324f5bc5c464a88daae21375e_3477426_120x120_fill_box_smart1_2.png","permalink":"https://minezeratul.github.io/p/4th-blog/","title":"xorQueries"},{"content":"Leetcode 872 Hello , 我是mz\n这是今天的每日一题872. 叶子相似的树\n题目要求获取这些叶子的值并按从左到右的顺序排列形成一个 叶值序列\n叶 ， 即无左右节点 , 并且还有按顺序，我们可以选择用中序遍历来完成要求\npublic boolean leafSimilar(TreeNode root1, TreeNode root2) { List\u0026lt;Integer\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); inorder(root1, list1); inorder(root2, list2); return list1.equals(list2); } private void inorder(TreeNode root, List\u0026lt;Integer\u0026gt; list) { if (root != null) { inorder(root.left, list); if (root.left == null \u0026amp;\u0026amp; root.right == null) list.add(root.val); inorder(root.right, list); } } 空间复杂度为O（n + m) ，n , m 分别为两个ArrayList\n需要遍历整个list ，因此时间复杂度为O（n + m)\n","date":"2021-05-08T00:00:00+08:00","image":"https://minezeratul.github.io/p/third-blog/wallhaven-5we787_hu30910665284931ace4f57faa1e01d828_921583_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/third-blog/","title":"leaf Similar"},{"content":"Leetcode 554 大家好，我是mz\n这是2021.5.2的每日一题554. 砖墙\n题目要求一条自顶向下 的、穿过 最少 砖块的垂线 ， 也可以理解为 总行数- 间隙最多\n这样就可以得出穿过最少砖块的路线\n我选择用了 [哈希表] 去记录了每个间隙所生成的位置 , 然后用Math.max去寻找最大间隙.\npublic int leastBricks(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; wall) { Map\u0026lt;Integer , Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (List\u0026lt;Integer\u0026gt; widths:wall){ int n = widths.size(); int sum = 0; for (int i = 0; i \u0026lt; n - 1; i++) { sum += widths.get(i); map.put(sum , map.getOrDefault(sum , 0) + 1);//记录间隙位置  } } int cnt = 0; for (Map.Entry\u0026lt;Integer , Integer\u0026gt; entry : map.entrySet()){\tcnt = Math.max(cnt , entry.getValue());//对比间隙  } return wall.size() - cnt; } 时间复杂度：O(nm) nn 是砖墙的高度，mm 是每行砖墙的砖的平均数量\n空间复杂度：O(nm)\n","date":"2021-05-08T00:00:00+08:00","image":"https://minezeratul.github.io/p/second-blog/wallhaven-pk8pzj_hu3d2822634ca48e852ce9c18a25e720d4_8322172_120x120_fill_box_smart1_2.png","permalink":"https://minezeratul.github.io/p/second-blog/","title":"Least Bricks"},{"content":"Hello , This is my first blog here I\u0026rsquo;m Minezeratul 今天的每日一题为 1486. 数组异或操作\n异或操作 , 即为XOR ， 同为0 ，异为1 ，1^0 = 1 0^0 = 0\npublic static int xorOperation(int n, int start) { if (n == 1) { return start; } int res = 0 ; for (int i = 0; i \u0026lt; n; i++) { res ^= start + 2 * i; } return res; } 时间复杂度为O(n)\n","date":"2021-05-07T00:00:00+08:00","image":"https://minezeratul.github.io/p/first-blog/wallhaven-x8ev3l_hu5438825b9b6d1014226d20d231e650c2_680482_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/first-blog/","title":"My First Blog here"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n 图片 \rPhoto by Florian Klauer on Unsplash\r \rPhoto by Luca Bravo on Unsplash\r\n\rPhoto by Helena Hertz on Unsplash\r \rPhoto by Hudai Gayiran on Unsplash\r\n![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://minezeratul.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","image":"https://minezeratul.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }","date":"2019-03-05T00:00:00Z","image":"https://minezeratul.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://minezeratul.github.io/p/emoji-support/","title":"Emoji Support"}]