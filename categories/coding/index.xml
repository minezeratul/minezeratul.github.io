<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coding on Minezeratul</title>
    <link>https://minezeratul.github.io/categories/coding/</link>
    <description>Recent content in Coding on Minezeratul</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 21 Jul 2021 19:31:34 +0800</lastBuildDate><atom:link href="https://minezeratul.github.io/categories/coding/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>UnionFind</title>
      <link>https://minezeratul.github.io/p/unionfind/</link>
      <pubDate>Wed, 21 Jul 2021 19:31:34 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/unionfind/</guid>
      <description>Union-Find 并查集 Union-Find 并查集算法的关键在于union和connected的效率 ， 若只是简单的连接节点 **find , union , connected **三个函数的时间复杂度会是O(n) ，而通过平衡树，可使复杂度降低到O(logn) 再而通过路径压缩，可使得union和connected的时间复杂度达到O(1) 这是优化版的Union-Find , 防止了树退化成链表而降低了效率 public class UnionFind { private int count;//连通分量个数  private int[] parent;//存储一棵树 , 记录每个节点的父节点，相当于指向父节点的指针  private int[] size;//记录每棵树重量  public UnionFind() { } public UnionFind(int n) { this.count = n; parent = new int[n]; size = new int[n]; for (int i = 0; i &amp;lt; n; i++) { parent[i] = i;//节点指向自己  size[i] = 1; } } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) { return; } //get the balanced tree  // 将两棵树合并为一棵树，小树接到大树下面，较平衡  // 使其不会退化成链表而降低效率  if (size[rootP] &amp;gt; size[rootQ]) { parent[rootQ] = rootP; size[rootP] += size[rootQ]; } else { parent[rootP] = rootQ; size[rootQ] += size[rootP]; } count--; } private int find(int x) { //路径压缩  while (parent[x] !</description>
    </item>
    
    <item>
      <title>Graph Algorithms Part II</title>
      <link>https://minezeratul.github.io/p/graph2/</link>
      <pubDate>Tue, 20 Jul 2021 09:24:47 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/graph2/</guid>
      <description>Graph Algorithms Part II. PrimMST 即时版本 用PriorityQueue存储vertex 详情可见algs4 4.3.5 不需要保存所有非树顶点w到树顶点的边，而只需要保存其中权重最小的那条，将v添加后检查是否需要更新这条权重最小的边
public MST getMinimumSpanningTree(int startingVertex) { List&amp;lt;Integer&amp;gt; T = new ArrayList&amp;lt;Integer&amp;gt;(); // T initially contains the startingVertex;  T.add(startingVertex); // Number of vertices  int numberOfVertices = vertices.size(); // Parent of a vertex  int[] parent = new int[numberOfVertices]; // Initially set the parent of all vertices to -1  Arrays.fill(parent, -1); // Total weight of the tree thus far  double totalWeight = 0; // Clone the priority queue, so to keep the original queue intact  List&amp;lt;PriorityQueue&amp;lt;WeightedEdge&amp;gt;&amp;gt; queues = deepClone(this.</description>
    </item>
    
    <item>
      <title>String Freq Sort</title>
      <link>https://minezeratul.github.io/p/leetcode-451/</link>
      <pubDate>Tue, 06 Jul 2021 15:33:26 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/leetcode-451/</guid>
      <description>Leetcode 451 451. 根据字符出现频率排序 利用hashmap记录 ， 或者用数组模拟hashmap , 然后利用PriorityQueue大顶堆来排序
public String frequencySort(String s) { StringBuilder sb = new StringBuilder(); //Map&amp;lt;Character , Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();  //for (char ch : s.toCharArray()){  // map.put(ch , map.getOrDefault(ch , 0 ) + 1);  //}  //也可以开一个128的数组替换 , 优化性能  int[] frequency = new int[128]; for (char ch : s.toCharArray()){ frequency[ch]++; } PriorityQueue&amp;lt;node&amp;gt; pq = new PriorityQueue&amp;lt;node&amp;gt;((o1 , o2) -&amp;gt; o1.freq !</description>
    </item>
    
    <item>
      <title>FindErrorNum</title>
      <link>https://minezeratul.github.io/p/leetcode-645/</link>
      <pubDate>Tue, 06 Jul 2021 10:08:44 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/leetcode-645/</guid>
      <description>Leetcode 645 FindErrorNum 645. 错误的集合 第一种方法，用数组模拟哈希表，获取出现次数
public int[] findErrorNums(int[] nums) { int n = nums.length; int[] res = new int[2];//导致集合丢失了一个数字 并且有一个数字重复。  int[] tmp = new int[n + 1]; for (int num : nums){ //统计次数  tmp[num]++; } for (int i = 1; i &amp;lt; tmp.length; i++) { if (tmp[i] == 1){ //有效  continue; } if (tmp[i] == 2){ //duplicated  res[0] = i; }else { //lost  res[1] = i; } } return res; } 第二种方法 ， 数学</description>
    </item>
    
    <item>
      <title>Passing message</title>
      <link>https://minezeratul.github.io/p/leetcode-lcp07/</link>
      <pubDate>Mon, 05 Jul 2021 16:15:12 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/leetcode-lcp07/</guid>
      <description>Leetcode LCP-07 LCP 07. 传递信息 看用例就可以知道这是一个图，[u , v]
用dfs深度优先来一步一步搜寻到末端
public int numWays(int n, int[][] relations, int k) { int cnt = 0; boolean[][] isVisited = new boolean[n][n];//判断是否经过  for (int[] relation : relations) { isVisited[relation[0]][relation[1]] = true; } return dfs(0 , isVisited , k); } public int dfs(int n , boolean[][] isVisited , int k){ if (k == 0){ return isVisited.length - 1 == n ? 1 : 0; } int cnt = 0 ; for (int i = 0; i &amp;lt; isVisited[n].</description>
    </item>
    
    <item>
      <title>Ice-Cream</title>
      <link>https://minezeratul.github.io/p/leetcode-1833/</link>
      <pubDate>Mon, 05 Jul 2021 15:51:33 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/leetcode-1833/</guid>
      <description>Leetcode 1833 1833. 雪糕的最大数量 夏天到了，终于放暑假了！LeetCode也叫人吃雪糕了
由题意可知，要买最多雪糕，可以想出贪心
第一种做法
public int maxIceCream(int[] costs, int coins) { int cnt = 0; Arrays.sort(costs);//sorted,从最便宜的开始买  for(int cost : costs){ if(coins &amp;gt;= cost){//超过即退出  coins -= cost; cnt++; }else{ break; } } return cnt; } 第二种排序，用计数排序来实现
public int maxIceCream2(int[] costs, int coins) { int[] freq = new int[100001]; for (int cost:costs){ //用数组模拟哈希表记录出现次数  freq[cost]++; } int cnt = 0; for (int i = 1; i &amp;lt;= 100000; i++) { if (coins &amp;gt;= i) {//超过即退出  int curCount = Math.</description>
    </item>
    
    <item>
      <title>Graph Algorithms Part I.2</title>
      <link>https://minezeratul.github.io/p/graph1.2/</link>
      <pubDate>Fri, 02 Jul 2021 23:58:08 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/graph1.2/</guid>
      <description>Graph Algorithms Part I.2 小优化 用数组isTnT 代替contains()去查找一个顶点u是否在T里 MST public MST getMinimumSpanningTree(int startingVertex) { // cost[v] stores the cost by adding v to the tree  double[] cost = new double[getSize()]; // Initial cost  Arrays.fill(cost, Double.POSITIVE_INFINITY); cost[startingVertex] = 0; // Cost of source is 0  int[] parent = new int[getSize()]; // Parent of a vertex  parent[startingVertex] = -1; // startingVertex is the root  double totalWeight = 0; // Total weight of the tree thus far  List&amp;lt;Integer&amp;gt; T = new ArrayList&amp;lt;&amp;gt;(); boolean[] isTnT = new boolean[getSize()]; // Expand T  while (T.</description>
    </item>
    
    <item>
      <title>Graph Algorithms Part I</title>
      <link>https://minezeratul.github.io/p/graph/</link>
      <pubDate>Wed, 02 Jun 2021 23:58:08 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/graph/</guid>
      <description>Graph Algorithms Part I. MST 最小生成树 public class MST extends Tree { private double totalWeight; // Total weight of all edges in the tree  public MST(int root, int[] parent, List&amp;lt;Integer&amp;gt; searchOrder, double totalWeight) { super(root, parent, searchOrder); this.totalWeight = totalWeight; } public double getTotalWeight() { return totalWeight; } } ShortestPathTree类 public class ShortestPathTree extends Tree{ private double[] cost; public ShortestPathTree(int source , int[] parent , List&amp;lt;Integer&amp;gt; searchOrder , double[] cost){ super(source , parent , searchOrder); this.</description>
    </item>
    
    <item>
      <title>CheckSubArray</title>
      <link>https://minezeratul.github.io/p/leetcode-523/</link>
      <pubDate>Wed, 02 Jun 2021 09:46:48 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/leetcode-523/</guid>
      <description>Leetcode 523 523. 连续的子数组和 给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：
子数组大小 至少为2 ，且子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。
如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。
public boolean checkSubarraySum(int[] nums, int k) { int n = nums.length; if (n &amp;lt; 2) {//大小至少为2  return false; } //利用了同余定理  //即 ( pre(j) - pre (i) ) % k == 0 则 pre(j) % k == pre(i) % k  //推导 =&amp;gt; pre (i) % k = (a0 + a1 + .</description>
    </item>
    
    <item>
      <title>Week-243 chubao</title>
      <link>https://minezeratul.github.io/p/lcweek243/</link>
      <pubDate>Sun, 30 May 2021 16:09:40 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/lcweek243/</guid>
      <description>触宝周赛Week 243 不会做最后一题哈哈哈
第一题5772. 检查某单词是否等于两单词之和
public boolean isSumEqual(String firstWord, String secondWord, String targetWord) { int ans = decode(firstWord) + decode(secondWord); return ans == decode(targetWord); } private int decode(String str) { int n = str.length(); int cnt = 0; //从个位开始计算  for (int i = n - 1, j = 1; i &amp;gt;= 0; i--, j = j * 10) { cnt += ((str.charAt(i) - &amp;#39;a&amp;#39;) * j); } return cnt; } 第二题 5773.</description>
    </item>
    
    <item>
      <title>Hamming algs</title>
      <link>https://minezeratul.github.io/p/hamming/</link>
      <pubDate>Sat, 29 May 2021 08:58:15 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/hamming/</guid>
      <description>Leetcode 477 这是5.28的每日一题477. 汉明距离总和
两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。
给你一个整数数组 nums，请你计算并返回 nums 中任意两个数之间汉明距离的总和。
Input:[4,14,2] Output:6
题目要求数组的长度不超过 10^4。说明不能用 O^2 的时间复杂度的解法 , 所以461. 汉明距离的解法会超时
public int totalHammingDistance(int[] nums) { int ans = 0, n = nums.length; //10^9 &amp;lt; 2^30 ， 枚举到29位  for (int i = 0; i &amp;lt; 30; ++i) { int c = 0; for (int val : nums) { //来取出其第 i 位的值 , 得出不同位  c += (val &amp;gt;&amp;gt; i) &amp;amp; 1; } ans += c * (n - c); } return ans; } 461.</description>
    </item>
    
    <item>
      <title>My First Blog here</title>
      <link>https://minezeratul.github.io/p/first-blog/</link>
      <pubDate>Fri, 07 May 2021 00:00:00 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/first-blog/</guid>
      <description>Hello , This is my first blog here I&amp;rsquo;m Minezeratul 今天的每日一题为 1486. 数组异或操作
异或操作 , 即为XOR ， 同为0 ，异为1 ，1^0 = 1 0^0 = 0
public static int xorOperation(int n, int start) { if (n == 1) { return start; } int res = 0 ; for (int i = 0; i &amp;lt; n; i++) { res ^= start + 2 * i; } return res; } 时间复杂度为O(n)</description>
    </item>
    
  </channel>
</rss>
