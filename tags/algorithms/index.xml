<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms on Minezeratul</title>
    <link>https://minezeratul.github.io/tags/algorithms/</link>
    <description>Recent content in Algorithms on Minezeratul</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 21 Jul 2021 19:31:34 +0800</lastBuildDate><atom:link href="https://minezeratul.github.io/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>UnionFind</title>
      <link>https://minezeratul.github.io/p/unionfind/</link>
      <pubDate>Wed, 21 Jul 2021 19:31:34 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/unionfind/</guid>
      <description>Union-Find 并查集 Union-Find 并查集算法的关键在于union和connected的效率 ， 若只是简单的连接节点 **find , union , connected **三个函数的时间复杂度会是O(n) ，而通过平衡树，可使复杂度降低到O(logn) 再而通过路径压缩，可使得union和connected的时间复杂度达到O(1) 这是优化版的Union-Find , 防止了树退化成链表而降低了效率 public class UnionFind { private int count;//连通分量个数  private int[] parent;//存储一棵树 , 记录每个节点的父节点，相当于指向父节点的指针  private int[] size;//记录每棵树重量  public UnionFind() { } public UnionFind(int n) { this.count = n; parent = new int[n]; size = new int[n]; for (int i = 0; i &amp;lt; n; i++) { parent[i] = i;//节点指向自己  size[i] = 1; } } public void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) { return; } //get the balanced tree  // 将两棵树合并为一棵树，小树接到大树下面，较平衡  // 使其不会退化成链表而降低效率  if (size[rootP] &amp;gt; size[rootQ]) { parent[rootQ] = rootP; size[rootP] += size[rootQ]; } else { parent[rootP] = rootQ; size[rootQ] += size[rootP]; } count--; } private int find(int x) { //路径压缩  while (parent[x] !</description>
    </item>
    
    <item>
      <title>Graph Algorithms Part II</title>
      <link>https://minezeratul.github.io/p/graph2/</link>
      <pubDate>Tue, 20 Jul 2021 09:24:47 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/graph2/</guid>
      <description>Graph Algorithms Part II. PrimMST 即时版本 用PriorityQueue存储vertex 详情可见algs4 4.3.5 不需要保存所有非树顶点w到树顶点的边，而只需要保存其中权重最小的那条，将v添加后检查是否需要更新这条权重最小的边
public MST getMinimumSpanningTree(int startingVertex) { List&amp;lt;Integer&amp;gt; T = new ArrayList&amp;lt;Integer&amp;gt;(); // T initially contains the startingVertex;  T.add(startingVertex); // Number of vertices  int numberOfVertices = vertices.size(); // Parent of a vertex  int[] parent = new int[numberOfVertices]; // Initially set the parent of all vertices to -1  Arrays.fill(parent, -1); // Total weight of the tree thus far  double totalWeight = 0; // Clone the priority queue, so to keep the original queue intact  List&amp;lt;PriorityQueue&amp;lt;WeightedEdge&amp;gt;&amp;gt; queues = deepClone(this.</description>
    </item>
    
    <item>
      <title>Graph Algorithms Part I.2</title>
      <link>https://minezeratul.github.io/p/graph1.2/</link>
      <pubDate>Fri, 02 Jul 2021 23:58:08 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/graph1.2/</guid>
      <description>Graph Algorithms Part I.2 小优化 用数组isTnT 代替contains()去查找一个顶点u是否在T里 MST public MST getMinimumSpanningTree(int startingVertex) { // cost[v] stores the cost by adding v to the tree  double[] cost = new double[getSize()]; // Initial cost  Arrays.fill(cost, Double.POSITIVE_INFINITY); cost[startingVertex] = 0; // Cost of source is 0  int[] parent = new int[getSize()]; // Parent of a vertex  parent[startingVertex] = -1; // startingVertex is the root  double totalWeight = 0; // Total weight of the tree thus far  List&amp;lt;Integer&amp;gt; T = new ArrayList&amp;lt;&amp;gt;(); boolean[] isTnT = new boolean[getSize()]; // Expand T  while (T.</description>
    </item>
    
    <item>
      <title>Graph Algorithms Part I</title>
      <link>https://minezeratul.github.io/p/graph/</link>
      <pubDate>Wed, 02 Jun 2021 23:58:08 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/graph/</guid>
      <description>Graph Algorithms Part I. MST 最小生成树 public class MST extends Tree { private double totalWeight; // Total weight of all edges in the tree  public MST(int root, int[] parent, List&amp;lt;Integer&amp;gt; searchOrder, double totalWeight) { super(root, parent, searchOrder); this.totalWeight = totalWeight; } public double getTotalWeight() { return totalWeight; } } ShortestPathTree类 public class ShortestPathTree extends Tree{ private double[] cost; public ShortestPathTree(int source , int[] parent , List&amp;lt;Integer&amp;gt; searchOrder , double[] cost){ super(source , parent , searchOrder); this.</description>
    </item>
    
  </channel>
</rss>
