<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dp on Minezeratul</title>
    <link>https://minezeratul.github.io/tags/dp/</link>
    <description>Recent content in dp on Minezeratul</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 Sep 2021 21:02:34 +0800</lastBuildDate><atom:link href="https://minezeratul.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>House Robber打家劫舍</title>
      <link>https://minezeratul.github.io/p/rob/</link>
      <pubDate>Wed, 29 Sep 2021 21:02:34 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/rob/</guid>
      <description>House Robber 打家劫舍 经典dp问题 , 如何获取最大金额
198. 打家劫舍 隔间偷窃 , 判断 [A + C , B]
public int rob(int[] nums) { //一维dp  int n = nums.length; if (n == 0) { return 0; } else if (n == 1) { return nums[0]; } int[] dp = new int[n + 1]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &amp;lt; n; i++) { dp[i] = Math.</description>
    </item>
    
    <item>
      <title>Stocks股票问题</title>
      <link>https://minezeratul.github.io/p/stock/</link>
      <pubDate>Wed, 29 Sep 2021 11:20:07 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/stock/</guid>
      <description>股票问题 我们需要注意的是交易次数k的限制
 121. 买卖股票的最佳时机 股票入门题目  只有一次交易机会，我们只需要找到最小价格日和最大价格日即可解决问题
 //交易次数k的限制  //k = 1  public int maxProfit(int[] prices) { int n = prices.length; int profit = 0, buy = prices[0]; for (int i = 1; i &amp;lt; n; i++) { profit = Math.max(profit, prices[i] - buy); buy = Math.min(buy, prices[i]); } return profit; } 122. 买卖股票的最佳时机 II  122则可以进行多次交易，我们需要用dp状态机来解决问题
   dp[i][0]表示未持有股票
  dp[i][1]表示持有股票
dp[i][0]状态则从前一天的(未持有 ，持有卖出)转移 ,</description>
    </item>
    
    <item>
      <title>Rob me if u can</title>
      <link>https://minezeratul.github.io/p/eighth-blog/</link>
      <pubDate>Sun, 16 May 2021 00:47:24 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/eighth-blog/</guid>
      <description>Leetcode 740 5.5的题目740. 删除并获得点数 和 198. 打家劫舍 有点类似 , 需要在一些地方做出调整
为了做740，先去当了一遍小偷XDDD
打家劫舍，经典dp问题，偷还得隔间偷,甚至开了透视知道哪里最多钱（笑
一间的时候肯定只能偷那个，两间的时候就需要Math.max比较
n间的时候则需要 when i &amp;gt; 2 , Math.max(dp[i - 2] + num[i] , dp[i - 1])来比较金额大小
public int rob(int[] nums) { int n = nums.length; if (n == 0 || nums == null) return 0; else if (n == 1) return nums[0]; /** int[] dp = new int[n]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &amp;lt; n; i++) { dp[i] = Math.</description>
    </item>
    
  </channel>
</rss>
