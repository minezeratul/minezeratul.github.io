<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BinarySearch on Minezeratul</title>
    <link>https://minezeratul.github.io/tags/binarysearch/</link>
    <description>Recent content in BinarySearch on Minezeratul</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 Apr 2022 15:04:53 +0800</lastBuildDate><atom:link href="https://minezeratul.github.io/tags/binarysearch/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SearchRange经典二分问题</title>
      <link>https://minezeratul.github.io/p/searchrange%E7%BB%8F%E5%85%B8%E4%BA%8C%E5%88%86%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 10 Apr 2022 15:04:53 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/searchrange%E7%BB%8F%E5%85%B8%E4%BA%8C%E5%88%86%E9%97%AE%E9%A2%98/</guid>
      <description>二分查找 模板题 704. 二分查找 二分查找是一种效率较高的方法(logN) , 它的要求是线性表中元素是有序的
我们常见的写法有：
public int binarySearch(int[] nums , int target){ int left = 0 , right = nums.length - 1; while(left &amp;lt;= right){ //left &amp;gt; right则退出，此时搜索区间为[left , right]  int mid = left + (right - left) / 2;//(left + right) / 2  if (nums[mid] == target){ return mid; }else if (nums[mid] &amp;gt; target){ right = mid - 1; }else if (nums[mid] &amp;lt; target){ left = mid + 1; } } return -1; } 另一种写法：</description>
    </item>
    
    <item>
      <title>minDays 1482</title>
      <link>https://minezeratul.github.io/p/seventh-blog/</link>
      <pubDate>Sat, 15 May 2021 20:47:24 +0800</pubDate>
      
      <guid>https://minezeratul.github.io/p/seventh-blog/</guid>
      <description>Leetcode 1482 这是5.9号的题目 1482. 制作 m 束花所需的最少天数
二分的应用场景不一定有序，只要具备排他性、两段性，就可以二分
寻找最优临界值的题目，往往可以借助二分搜索
/** * @param bloomDay 什么时候开花 * @param m m束 * @param k k朵花做成一束 * @return */ public static int minDays(int[] bloomDay, int m, int k) { int n = bloomDay.length; if (n &amp;lt; m * k)//不够花束  return -1; int low = Integer.MAX_VALUE, high = 0; for (int i = 0; i &amp;lt; n; i++) { low = Math.min(low, bloomDay[i]);//找到最小值作为low  high = Math.</description>
    </item>
    
  </channel>
</rss>
